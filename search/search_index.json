{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyOpenSourceProjects API Documentation","text":""},{"location":"#osprojects.checkos","title":"<code>checkos</code>","text":"<p>Created on 2024-07-30</p> <p>@author: wf</p>"},{"location":"#osprojects.checkos.CheckOS","title":"<code>CheckOS</code>","text":"<p>check the open source projects</p> Source code in <code>osprojects/checkos.py</code> <pre><code>class CheckOS:\n    \"\"\"\n    check the open source projects\n    \"\"\"\n\n    def __init__(self, args: Namespace, project: OsProject):\n        self.args = args\n        self.verbose = args.verbose\n        self.workspace = args.workspace\n        self.project = project\n        self.project_path = os.path.join(self.workspace, project.id)\n        self.checks = []\n        # python 3.12 is max version\n        self.max_python_version_minor=12\n\n    @property\n    def total(self) -&gt; int:\n        return len(self.checks)\n\n    @property\n    def ok_checks(self) -&gt; List[Check]:\n        ok_checks = [check for check in self.checks if check.ok]\n        return ok_checks\n\n    @property\n    def failed_checks(self) -&gt; List[Check]:\n        failed_checks = [check for check in self.checks if not check.ok]\n        return failed_checks\n\n    def add_check(self, ok, msg:str=\"\",path: str=None,negative:bool=False) -&gt; Check:\n        if not path:\n            raise ValueError(\"path parameter missing\")\n        marker=\"\"\n        if negative:\n            ok=not ok\n            marker=\"\u26a0 \ufe0f\"\n        check = Check(ok=ok, path=path, msg=f\"{marker}{msg}{path}\")\n        self.checks.append(check)\n        return check\n\n    def add_content_check(self, content: str, needle: str, path: str, negative:bool=False) -&gt; Check:\n        ok=needle in content\n        check=self.add_check(ok, msg=f\"{needle} in \", path=path,negative=negative)\n        return check\n\n    def add_path_check(self, path) -&gt; Check:\n        # Check if path exists\n        path_exists = Check.file_exists(path)\n        self.checks.append(path_exists)\n        return path_exists\n\n    def check_local(self) -&gt; Check:\n        local = Check.file_exists(self.project_path)\n        return local\n\n    def check_github_workflows(self):\n        workflows_path = os.path.join(self.project_path, \".github\", \"workflows\")\n        workflows_exist = self.add_path_check(workflows_path)\n\n        if workflows_exist.ok:\n            required_files = [\"build.yml\", \"upload-to-pypi.yml\"]\n            for file in required_files:\n                file_path = os.path.join(workflows_path, file)\n                file_exists = self.add_path_check(file_path)\n\n                if file_exists.ok:\n                    content = file_exists.content\n\n                    if file == \"build.yml\":\n                        min_python_version_minor = int(self.requires_python.split('.')[-1])\n                        self.add_check(min_python_version_minor==self.min_python_version_minor,msg=f\"{min_python_version_minor} (build.yml)!={self.min_python_version_minor} (pyprojec.toml)\",path=file_path)\n                        python_versions = f\"\"\"python-version: [ {', '.join([f\"'3.{i}'\" for i in range(self.min_python_version_minor, self.max_python_version_minor+1)])} ]\"\"\"\n                        self.add_content_check(\n                            content,\n                            python_versions,\n                            file_path,\n                        )\n                        self.add_content_check(\n                            content,\n                            \"os: [ubuntu-latest, macos-latest, windows-latest]\",\n                            file_path,\n                        )\n                        self.add_content_check(content, \"uses: actions/checkout@v4\", file_path)\n                        self.add_content_check(\n                            content,\n                            \"uses: actions/setup-python@v5\",\n                            file_path,\n                        )\n\n                        self.add_content_check(\n                            content,\n                            \"sphinx\",\n                            file_path,\n                            negative=True\n                        )\n                        scripts_ok=\"scripts/install\" in content and \"scripts/test\" in content or \"scripts/installAndTest\" in content\n                        self.add_check(scripts_ok,\"install and test\", file_path)\n\n                    elif file == \"upload-to-pypi.yml\":\n                        self.add_content_check(content, \"id-token: write\", file_path)\n                        self.add_content_check(content, \"uses: actions/checkout@v4\", file_path)\n                        self.add_content_check(\n                            content,\n                            \"uses: actions/setup-python@v5\",\n                            file_path,\n                        )\n                        self.add_content_check(\n                            content,\n                            \"uses: pypa/gh-action-pypi-publish@release/v1\",\n                            file_path,\n                        )\n\n    def check_scripts(self):\n        scripts_path = os.path.join(self.project_path, \"scripts\")\n        scripts_exist = self.add_path_check(scripts_path)\n        if scripts_exist.ok:\n            required_files = [\"blackisort\", \"test\", \"install\", \"doc\", \"release\"]\n            for file in required_files:\n                file_path = os.path.join(scripts_path, file)\n                file_exists = self.add_path_check(file_path)\n                if file_exists.ok:\n                    content = file_exists.content\n                    if file==\"doc\":\n                        self.add_content_check(content, \"sphinx\", file_path, negative=True)\n                        self.add_content_check(content,\"WF 2024-07-30 - updated\",file_path)\n                    if file==\"release\":\n                        self.add_content_check(content, \"scripts/doc -d\", file_path)\n\n    def check_readme(self):\n        readme_path = os.path.join(self.project_path, \"README.md\")\n        readme_exists = self.add_path_check(readme_path)\n        if readme_exists.ok:\n            readme_content = readme_exists.content\n            badge_lines = [\n                \"[![pypi](https://img.shields.io/pypi/pyversions/{self.project_name})](https://pypi.org/project/{self.project_name}/)\",\n                \"[![Github Actions Build](https://github.com/{self.project.fqid}/actions/workflows/build.yml/badge.svg)](https://github.com/{self.project.fqid}/actions/workflows/build.yml)\",\n                \"[![PyPI Status](https://img.shields.io/pypi/v/{self.project_name}.svg)](https://pypi.python.org/pypi/{self.project_name}/)\",\n                \"[![GitHub issues](https://img.shields.io/github/issues/{self.project.fqid}.svg)](https://github.com/{self.project.fqid}/issues)\",\n                \"[![GitHub closed issues](https://img.shields.io/github/issues-closed/{self.project.fqid}.svg)](https://github.com/{self.project.fqid}/issues/?q=is%3Aissue+is%3Aclosed)\",\n                \"[![API Docs](https://img.shields.io/badge/API-Documentation-blue)](https://{self.project.owner}.github.io/{self.project.id}/)\",\n                \"[![License](https://img.shields.io/github/license/{self.project.fqid}.svg)](https://www.apache.org/licenses/LICENSE-2.0)\",\n            ]\n            for line in badge_lines:\n                formatted_line = line.format(self=self)\n                self.add_content_check(\n                    content=readme_content,\n                    needle=formatted_line,\n                    path=readme_path,\n                )\n            self.add_content_check(readme_content, \"readthedocs\", readme_path, negative=True)\n\n    def check_pyproject_toml(self):\n        \"\"\"\n        pyproject.toml\n        \"\"\"\n        toml_path = os.path.join(self.project_path, \"pyproject.toml\")\n        toml_exists = self.add_path_check(toml_path)\n        if toml_exists.ok:\n            content=toml_exists.content\n            toml_dict = tomllib.loads(content)\n            project_check=self.add_check(\"project\" in toml_dict, \"[project]\", toml_path)\n            if project_check.ok:\n                self.project_name=toml_dict[\"project\"][\"name\"]\n                requires_python_check=self.add_check(\"requires-python\" in toml_dict[\"project\"], \"requires-python\", toml_path)\n                if requires_python_check.ok:\n                    self.requires_python = toml_dict[\"project\"][\"requires-python\"]\n                    min_python_version = version.parse(self.requires_python.replace(\"&gt;=\", \"\"))\n                    min_version_needed=\"3.9\"\n                    version_ok=min_python_version &gt;= version.parse(min_version_needed)\n                    self.add_check(version_ok, f\"requires-python&gt;={min_version_needed}\", toml_path)\n                    self.min_python_version_minor=int(str(min_python_version).split('.')[-1])\n                    for minor_version in range(self.min_python_version_minor, self.max_python_version_minor+1):\n                        needle=f\"Programming Language :: Python :: 3.{minor_version}\"\n                        self.add_content_check(content, needle, toml_path)\n            self.add_content_check(content, \"hatchling\", toml_path)\n            self.add_content_check(content,\"[tool.hatch.build.targets.wheel.sources]\",toml_path)\n\n\n    def check(self,title:str):\n        \"\"\"\n        Check the given project and print results\n        \"\"\"\n        self.check_local()\n        self.check_pyproject_toml()\n        self.check_github_workflows()\n        self.check_readme()\n        self.check_scripts()\n\n\n        # ok_count=len(ok_checks)\n        failed_count = len(self.failed_checks)\n        summary = f\"\u274c {failed_count:2}/{self.total:2}\" if failed_count &gt; 0 else f\"\u2705 {self.total:2}/{self.total:2}\"\n        print(f\"{title}{summary}:{self.project}\u2192{self.project.url}\")\n        if failed_count &gt; 0:\n            # Sort checks by path\n            sorted_checks = sorted(self.checks, key=lambda c: c.path or \"\")\n\n            # Group checks by path\n            checks_by_path = {}\n            for check in sorted_checks:\n                if check.path not in checks_by_path:\n                    checks_by_path[check.path] = []\n                checks_by_path[check.path].append(check)\n\n            # Display results\n            for path, path_checks in checks_by_path.items():\n                path_failed = sum(1 for c in path_checks if not c.ok)\n                if path_failed &gt; 0 or self.args.debug:\n                    print(f\"\u274c {path}: {path_failed}\")\n                    i=0\n                    for check in path_checks:\n                        show=not check.ok or self.args.debug\n                        if show:\n                            i+=1\n                            print(f\"    {i:3}{check.marker}:{check.msg}\")\n\n                    if self.args.editor and path_failed &gt; 0:\n                        if os.path.isfile(path):\n                            # @TODO Make editor configurable\n                            Editor.open(path,default_editor_cmd=\"/usr/local/bin/atom\")\n                        else:\n                            Editor.open_filepath(path)\n</code></pre>"},{"location":"#osprojects.checkos.CheckOS.check","title":"<code>check(title)</code>","text":"<p>Check the given project and print results</p> Source code in <code>osprojects/checkos.py</code> <pre><code>def check(self,title:str):\n    \"\"\"\n    Check the given project and print results\n    \"\"\"\n    self.check_local()\n    self.check_pyproject_toml()\n    self.check_github_workflows()\n    self.check_readme()\n    self.check_scripts()\n\n\n    # ok_count=len(ok_checks)\n    failed_count = len(self.failed_checks)\n    summary = f\"\u274c {failed_count:2}/{self.total:2}\" if failed_count &gt; 0 else f\"\u2705 {self.total:2}/{self.total:2}\"\n    print(f\"{title}{summary}:{self.project}\u2192{self.project.url}\")\n    if failed_count &gt; 0:\n        # Sort checks by path\n        sorted_checks = sorted(self.checks, key=lambda c: c.path or \"\")\n\n        # Group checks by path\n        checks_by_path = {}\n        for check in sorted_checks:\n            if check.path not in checks_by_path:\n                checks_by_path[check.path] = []\n            checks_by_path[check.path].append(check)\n\n        # Display results\n        for path, path_checks in checks_by_path.items():\n            path_failed = sum(1 for c in path_checks if not c.ok)\n            if path_failed &gt; 0 or self.args.debug:\n                print(f\"\u274c {path}: {path_failed}\")\n                i=0\n                for check in path_checks:\n                    show=not check.ok or self.args.debug\n                    if show:\n                        i+=1\n                        print(f\"    {i:3}{check.marker}:{check.msg}\")\n\n                if self.args.editor and path_failed &gt; 0:\n                    if os.path.isfile(path):\n                        # @TODO Make editor configurable\n                        Editor.open(path,default_editor_cmd=\"/usr/local/bin/atom\")\n                    else:\n                        Editor.open_filepath(path)\n</code></pre>"},{"location":"#osprojects.checkos.CheckOS.check_pyproject_toml","title":"<code>check_pyproject_toml()</code>","text":"<p>pyproject.toml</p> Source code in <code>osprojects/checkos.py</code> <pre><code>def check_pyproject_toml(self):\n    \"\"\"\n    pyproject.toml\n    \"\"\"\n    toml_path = os.path.join(self.project_path, \"pyproject.toml\")\n    toml_exists = self.add_path_check(toml_path)\n    if toml_exists.ok:\n        content=toml_exists.content\n        toml_dict = tomllib.loads(content)\n        project_check=self.add_check(\"project\" in toml_dict, \"[project]\", toml_path)\n        if project_check.ok:\n            self.project_name=toml_dict[\"project\"][\"name\"]\n            requires_python_check=self.add_check(\"requires-python\" in toml_dict[\"project\"], \"requires-python\", toml_path)\n            if requires_python_check.ok:\n                self.requires_python = toml_dict[\"project\"][\"requires-python\"]\n                min_python_version = version.parse(self.requires_python.replace(\"&gt;=\", \"\"))\n                min_version_needed=\"3.9\"\n                version_ok=min_python_version &gt;= version.parse(min_version_needed)\n                self.add_check(version_ok, f\"requires-python&gt;={min_version_needed}\", toml_path)\n                self.min_python_version_minor=int(str(min_python_version).split('.')[-1])\n                for minor_version in range(self.min_python_version_minor, self.max_python_version_minor+1):\n                    needle=f\"Programming Language :: Python :: 3.{minor_version}\"\n                    self.add_content_check(content, needle, toml_path)\n        self.add_content_check(content, \"hatchling\", toml_path)\n        self.add_content_check(content,\"[tool.hatch.build.targets.wheel.sources]\",toml_path)\n</code></pre>"},{"location":"#osprojects.checkos.main","title":"<code>main(_argv=None)</code>","text":"<p>main command line entry point</p> Source code in <code>osprojects/checkos.py</code> <pre><code>def main(_argv=None):\n    \"\"\"\n    main command line entry point\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Check open source projects\")\n    parser.add_argument(\n        \"-d\",\n        \"--debug\",\n        action=\"store_true\",\n        help=\"add debug output\",\n    )\n    parser.add_argument(\n        \"-e\",\n        \"--editor\",\n        action=\"store_true\",\n        help=\"open default editor on failed files\",\n    )\n    parser.add_argument(\n        \"-o\", \"--owner\", help=\"project owner or organization\", required=True\n    )\n    parser.add_argument(\"-p\", \"--project\", help=\"name of the project\")\n    parser.add_argument(\"-l\", \"--language\", help=\"filter projects by language\")\n    parser.add_argument(\n        \"--local\", action=\"store_true\", help=\"check only locally available projects\"\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\", action=\"store_true\", help=\"show verbose output\"\n    )\n    parser.add_argument(\n        \"-ws\",\n        \"--workspace\",\n        help=\"(Eclipse) workspace directory\",\n        default=os.path.expanduser(\"~/py-workspace\"),\n    )\n\n    args = parser.parse_args(args=_argv)\n\n    try:\n        github = GitHub()\n        if args.project:\n            # Check specific project\n            projects = github.list_projects_as_os_projects(\n                args.owner, project_name=args.project\n            )\n        else:\n            # Check all projects\n            projects = github.list_projects_as_os_projects(args.owner)\n\n        if args.language:\n            projects = [p for p in projects if p.language == args.language]\n\n        if args.local:\n            local_projects = []\n            for project in projects:\n                checker = CheckOS(args=args, project=project)\n                if checker.check_local().ok:\n                    local_projects.append(project)\n            projects = local_projects\n\n        for i,project in enumerate(projects):\n            checker = CheckOS(args=args, project=project)\n            checker.check(f\"{i+1:3}:\")\n    except Exception as ex:\n        if args.debug:\n            print(traceback.format_exc())\n        raise ex\n</code></pre>"},{"location":"#osprojects.editor","title":"<code>editor</code>","text":"<p>Created on 2022-11-27</p> <p>@author: wf</p>"},{"location":"#osprojects.editor.Editor","title":"<code>Editor</code>","text":"<p>helper class to open the system defined editor</p> <p>see https://stackoverflow.com/questions/1442841/lauch-default-editor-like-webbrowser-module</p> Source code in <code>osprojects/editor.py</code> <pre><code>class Editor:\n    \"\"\"\n    helper class to open the system defined editor\n\n    see https://stackoverflow.com/questions/1442841/lauch-default-editor-like-webbrowser-module\n    \"\"\"\n\n    @classmethod\n    def open_filepath(cls, filepath: str):\n        if platform.system() == \"Darwin\":  # macOS\n            subprocess.call((\"open\", filepath))\n        elif platform.system() == \"Windows\":  # Windows\n            os.startfile(filepath, \"open\")\n        else:  # linux variants\n            subprocess.call((\"xdg-open\", filepath))\n\n    @classmethod\n    def extract_text(cls, html_text: str) -&gt; str:\n        \"\"\"\n        extract the text from the given html_text\n\n        Args:\n            html_text(str): the input for the html text\n\n        Returns:\n            str: the plain text\n        \"\"\"\n        soup = BeautifulSoup(html_text, features=\"html.parser\")\n\n        # kill all script and style elements\n        for script in soup([\"script\", \"style\"]):\n            script.extract()  # rip it out\n\n        # get text\n        text = soup.get_text()\n\n        # break into lines and remove leading and trailing space on each\n        lines = (line.strip() for line in text.splitlines())\n        # break multi-headlines into a line each\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n        # drop blank lines\n        text = \"\\n\".join(chunk for chunk in chunks if chunk)\n        return text\n\n    @classmethod\n    def open(\n        cls,\n        file_source: str,\n        extract_text: bool = True,\n        default_editor_cmd: str = \"/usr/local/bin/atom\",\n    ) -&gt; str:\n        \"\"\"\n        open an editor for the given file_source\n\n        Args:\n            file_source(str): the path to the file\n            extract_text(bool): if True extract the text from html sources\n\n        Returns:\n            str: the path to the file e.g. a temporary file if the file_source points to an url\n        \"\"\"\n        # handle urls\n        # https://stackoverflow.com/a/45886824/1497139\n        if file_source.startswith(\"http\"):\n            url_source = urlopen(file_source)\n            # https://stackoverflow.com/a/19156107/1497139\n            charset = url_source.headers.get_content_charset()\n            # if charset fails here you might want to set it to utf-8 as a default!\n            text = url_source.read().decode(charset)\n            if extract_text:\n                # https://stackoverflow.com/a/24618186/1497139\n                text = cls.extract_text(text)\n\n            return cls.open_tmp_text(text)\n\n        editor_cmd = None\n        editor_env = os.getenv(\"EDITOR\")\n        if editor_env:\n            editor_cmd = editor_env\n        if platform.system() == \"Darwin\":\n            if not editor_env:\n                # https://stackoverflow.com/questions/22390709/how-can-i-open-the-atom-editor-from-the-command-line-in-os-x\n                editor_cmd = default_editor_cmd\n        if editor_cmd:\n            os_cmd = f\"{editor_cmd} {file_source}\"\n            os.system(os_cmd)\n        return file_source\n\n    @classmethod\n    def open_tmp_text(cls, text: str, file_name: str = None) -&gt; str:\n        \"\"\"\n        open an editor for the given text in a newly created temporary file\n\n        Args:\n            text(str): the text to write to a temporary file and then open\n            file_name(str): the name to use for the file\n\n        Returns:\n            str: the path to the temp file\n        \"\"\"\n        # see https://stackoverflow.com/a/8577226/1497139\n        # https://stackoverflow.com/a/3924253/1497139\n        with tempfile.NamedTemporaryFile(delete=False) as tmp:\n            with open(tmp.name, \"w\") as tmp_file:\n                tmp_file.write(text)\n                tmp_file.close()\n            if file_name is None:\n                file_path = tmp.name\n            else:\n                # https://stackoverflow.com/questions/3167154/how-to-split-a-dos-path-into-its-components-in-python\n                path = Path(tmp.name)\n                # https://stackoverflow.com/a/49798311/1497139\n                file_path = path.parent / file_name\n                os.rename(tmp.name, file_path)\n\n            return cls.open(str(file_path))\n</code></pre>"},{"location":"#osprojects.editor.Editor.extract_text","title":"<code>extract_text(html_text)</code>  <code>classmethod</code>","text":"<p>extract the text from the given html_text</p> <p>Parameters:</p> Name Type Description Default <code>html_text(str)</code> <p>the input for the html text</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the plain text</p> Source code in <code>osprojects/editor.py</code> <pre><code>@classmethod\ndef extract_text(cls, html_text: str) -&gt; str:\n    \"\"\"\n    extract the text from the given html_text\n\n    Args:\n        html_text(str): the input for the html text\n\n    Returns:\n        str: the plain text\n    \"\"\"\n    soup = BeautifulSoup(html_text, features=\"html.parser\")\n\n    # kill all script and style elements\n    for script in soup([\"script\", \"style\"]):\n        script.extract()  # rip it out\n\n    # get text\n    text = soup.get_text()\n\n    # break into lines and remove leading and trailing space on each\n    lines = (line.strip() for line in text.splitlines())\n    # break multi-headlines into a line each\n    chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n    # drop blank lines\n    text = \"\\n\".join(chunk for chunk in chunks if chunk)\n    return text\n</code></pre>"},{"location":"#osprojects.editor.Editor.open","title":"<code>open(file_source, extract_text=True, default_editor_cmd='/usr/local/bin/atom')</code>  <code>classmethod</code>","text":"<p>open an editor for the given file_source</p> <p>Parameters:</p> Name Type Description Default <code>file_source(str)</code> <p>the path to the file</p> required <code>extract_text(bool)</code> <p>if True extract the text from html sources</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path to the file e.g. a temporary file if the file_source points to an url</p> Source code in <code>osprojects/editor.py</code> <pre><code>@classmethod\ndef open(\n    cls,\n    file_source: str,\n    extract_text: bool = True,\n    default_editor_cmd: str = \"/usr/local/bin/atom\",\n) -&gt; str:\n    \"\"\"\n    open an editor for the given file_source\n\n    Args:\n        file_source(str): the path to the file\n        extract_text(bool): if True extract the text from html sources\n\n    Returns:\n        str: the path to the file e.g. a temporary file if the file_source points to an url\n    \"\"\"\n    # handle urls\n    # https://stackoverflow.com/a/45886824/1497139\n    if file_source.startswith(\"http\"):\n        url_source = urlopen(file_source)\n        # https://stackoverflow.com/a/19156107/1497139\n        charset = url_source.headers.get_content_charset()\n        # if charset fails here you might want to set it to utf-8 as a default!\n        text = url_source.read().decode(charset)\n        if extract_text:\n            # https://stackoverflow.com/a/24618186/1497139\n            text = cls.extract_text(text)\n\n        return cls.open_tmp_text(text)\n\n    editor_cmd = None\n    editor_env = os.getenv(\"EDITOR\")\n    if editor_env:\n        editor_cmd = editor_env\n    if platform.system() == \"Darwin\":\n        if not editor_env:\n            # https://stackoverflow.com/questions/22390709/how-can-i-open-the-atom-editor-from-the-command-line-in-os-x\n            editor_cmd = default_editor_cmd\n    if editor_cmd:\n        os_cmd = f\"{editor_cmd} {file_source}\"\n        os.system(os_cmd)\n    return file_source\n</code></pre>"},{"location":"#osprojects.editor.Editor.open_tmp_text","title":"<code>open_tmp_text(text, file_name=None)</code>  <code>classmethod</code>","text":"<p>open an editor for the given text in a newly created temporary file</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the text to write to a temporary file and then open</p> required <code>file_name(str)</code> <p>the name to use for the file</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path to the temp file</p> Source code in <code>osprojects/editor.py</code> <pre><code>@classmethod\ndef open_tmp_text(cls, text: str, file_name: str = None) -&gt; str:\n    \"\"\"\n    open an editor for the given text in a newly created temporary file\n\n    Args:\n        text(str): the text to write to a temporary file and then open\n        file_name(str): the name to use for the file\n\n    Returns:\n        str: the path to the temp file\n    \"\"\"\n    # see https://stackoverflow.com/a/8577226/1497139\n    # https://stackoverflow.com/a/3924253/1497139\n    with tempfile.NamedTemporaryFile(delete=False) as tmp:\n        with open(tmp.name, \"w\") as tmp_file:\n            tmp_file.write(text)\n            tmp_file.close()\n        if file_name is None:\n            file_path = tmp.name\n        else:\n            # https://stackoverflow.com/questions/3167154/how-to-split-a-dos-path-into-its-components-in-python\n            path = Path(tmp.name)\n            # https://stackoverflow.com/a/49798311/1497139\n            file_path = path.parent / file_name\n            os.rename(tmp.name, file_path)\n\n        return cls.open(str(file_path))\n</code></pre>"},{"location":"#osprojects.osproject","title":"<code>osproject</code>","text":"<p>Created on 2022-01-24</p> <p>@author: wf</p>"},{"location":"#osprojects.osproject.Commit","title":"<code>Commit</code>","text":"<p>               Bases: <code>object</code></p> <p>a commit</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class Commit(object):\n    \"\"\"\n    a commit\n    \"\"\"\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"host\": \"https://github.com/WolfgangFahl/pyOpenSourceProjects\",\n                \"path\": \"\",\n                \"project\": \"pyOpenSourceProjects\",\n                \"subject\": \"Initial commit\",\n                \"name\": \"GitHub\",  # TicketSystem\n                \"date\": datetime.datetime.fromisoformat(\"2022-01-24 07:02:55+01:00\"),\n                \"hash\": \"106254f\",\n            }\n        ]\n        return samples\n\n    def toWikiMarkup(self):\n        \"\"\"\n        Returns Commit as wiki markup\n        \"\"\"\n        params = [\n            f\"{attr}={getattr(self, attr, '')}\" for attr in self.getSamples()[0].keys()\n        ]\n        markup = f\"{{{{commit|{'|'.join(params)}|storemode=subobject|viewmode=line}}}}\"\n        return markup\n</code></pre>"},{"location":"#osprojects.osproject.Commit.toWikiMarkup","title":"<code>toWikiMarkup()</code>","text":"<p>Returns Commit as wiki markup</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def toWikiMarkup(self):\n    \"\"\"\n    Returns Commit as wiki markup\n    \"\"\"\n    params = [\n        f\"{attr}={getattr(self, attr, '')}\" for attr in self.getSamples()[0].keys()\n    ]\n    markup = f\"{{{{commit|{'|'.join(params)}|storemode=subobject|viewmode=line}}}}\"\n    return markup\n</code></pre>"},{"location":"#osprojects.osproject.GitHub","title":"<code>GitHub</code>","text":"<p>               Bases: <code>TicketSystem</code></p> <p>wrapper for the GitHub api</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class GitHub(TicketSystem):\n    \"\"\"\n    wrapper for the GitHub api\n    \"\"\"\n\n    @classmethod\n    def load_access_token(cls) -&gt; str:\n        \"\"\"\n        if $HOME/.github/access_token.json exists read the token from there\n        \"\"\"\n        # Specify the path to the access token file\n        token_file_path = os.path.join(\n            os.getenv(\"HOME\"), \".github\", \"access_token.json\"\n        )\n\n        # Check if the file exists and read the token\n        if os.path.exists(token_file_path):\n            with open(token_file_path, \"r\") as token_file:\n                token_data = json.load(token_file)\n                return token_data.get(\"access_token\")\n\n        # Return None if no token file is found\n        return None\n\n    @classmethod\n    def prepare_headers(cls, access_token: str = None) -&gt; dict:\n        \"\"\"\n        Prepare authorization headers for GitHub API requests.\n        \"\"\"\n        if access_token is None:\n            access_token = cls.load_access_token()\n\n        headers = {\"Authorization\": f\"token {access_token}\"} if access_token else {}\n        return headers\n\n    @classmethod\n    def list_projects_as_os_projects(\n        cls, owner: str, access_token: str = None, project_name: Optional[str] = None\n    ) -&gt; List[OsProject]:\n        \"\"\"\n        List all public repositories for a given owner and return them as OsProject instances.\n\n        Args:\n            owner (str): The GitHub username or organization name.\n            access_token (str, optional): GitHub personal access token for authentication.\n            project_name (str, optional): If provided, return only this specific project.\n\n        Returns:\n            List[OsProject]: A list of OsProject instances representing the repositories.\n        \"\"\"\n        headers = cls.prepare_headers(access_token)\n\n        if project_name:\n            url = f\"https://api.github.com/repos/{owner}/{project_name}\"\n            response = requests.get(url, headers=headers)\n            if response.status_code != 200:\n                raise Exception(\n                    f\"Failed to fetch repository: {response.status_code} - {response.text}\"\n                )\n            repos = [response.json()]\n        else:\n            url = f\"https://api.github.com/users/{owner}/repos\"\n            params = {\n                \"type\": \"all\",\n                \"per_page\": 100,\n            }  # Include all repo types, 100 per page\n            all_repos = []\n            page = 1\n\n            while True:\n                params[\"page\"] = page\n                response = requests.get(url, headers=headers, params=params)\n\n                if response.status_code != 200:\n                    raise Exception(\n                        f\"Failed to fetch repositories: {response.status_code} - {response.text}\"\n                    )\n\n                repos = response.json()\n                if not repos:\n                    break  # No more repositories to fetch\n\n                all_repos.extend(repos)\n                page += 1\n\n            repos = all_repos\n\n        return [\n            OsProject(\n                owner=owner,\n                id=repo[\"name\"],\n                ticketSystem=cls,\n                title=repo[\"name\"],\n                url=repo[\"html_url\"],\n                description=repo[\"description\"],\n                language=repo[\"language\"],\n                created_at=datetime.datetime.fromisoformat(\n                    repo[\"created_at\"].rstrip(\"Z\")\n                ),\n                updated_at=datetime.datetime.fromisoformat(\n                    repo[\"updated_at\"].rstrip(\"Z\")\n                ),\n                stars=repo[\"stargazers_count\"],\n                forks=repo[\"forks_count\"],\n            )\n            for repo in repos\n        ]\n\n    @classmethod\n    def get_project(\n        cls, owner: str, project_id: str, access_token: str = None\n    ) -&gt; OsProject:\n        \"\"\"\n        Get a specific project as an OsProject instance.\n\n        Args:\n            owner (str): The GitHub username or organization name.\n            project_id (str): The name of the project.\n            access_token (str, optional): GitHub personal access token for authentication.\n\n        Returns:\n            OsProject: An OsProject instance representing the repository.\n        \"\"\"\n        projects = cls.list_projects_as_os_projects(\n            owner, access_token, project_name=project_id\n        )\n        if projects:\n            return projects[0]\n        raise Exception(f\"Project {owner}/{project_id} not found\")\n\n    @classmethod\n    def getIssues(\n        cls, project: OsProject, access_token: str = None, limit: int = None, **params\n    ) -&gt; List[Ticket]:\n        payload = {}\n        headers = cls.prepare_headers(access_token)\n        issues = []\n        nextResults = True\n        params[\"per_page\"] = 100\n        params[\"page\"] = 1\n        fetched_count = 0  # Counter to track the number of issues fetched\n        while nextResults:\n            response = requests.request(\n                \"GET\",\n                GitHub.ticketUrl(project),\n                headers=headers,\n                data=payload,\n                params=params,\n            )\n            if response.status_code == 403 and \"rate limit\" in response.text:\n                raise Exception(\"rate limit - you might want to use an access token\")\n            issue_records = json.loads(response.text)\n            for record in issue_records:\n                tr = {\n                    \"project\": project,\n                    \"title\": record.get(\"title\"),\n                    \"body\": record.get(\"body\", \"\"),\n                    \"createdAt\": (\n                        parse(record.get(\"created_at\"))\n                        if record.get(\"created_at\")\n                        else \"\"\n                    ),\n                    \"closedAt\": (\n                        parse(record.get(\"closed_at\"))\n                        if record.get(\"closed_at\")\n                        else \"\"\n                    ),\n                    \"state\": record.get(\"state\"),\n                    \"number\": record.get(\"number\"),\n                    \"url\": f\"{cls.projectUrl(project)}/issues/{record.get('number')}\",\n                }\n                issues.append(Ticket.init_from_dict(**tr))\n                fetched_count += 1\n                # Check if we have reached the limit\n                if limit is not None and fetched_count &gt;= limit:\n                    nextResults = False\n                    break\n\n            if len(issue_records) &lt; 100:\n                nextResults = False\n            else:\n                params[\"page\"] += 1\n        return issues\n\n    @classmethod\n    def getComments(\n        cls, project: OsProject, issue_number: int, access_token: str = None\n    ) -&gt; List[dict]:\n        \"\"\"\n        Fetch all comments for a specific issue number from GitHub.\n        \"\"\"\n        headers = cls.prepare_headers(access_token)\n        comments_url = GitHub.commentUrl(project, issue_number)\n        response = requests.get(comments_url, headers=headers)\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise Exception(\n                f\"Failed to fetch comments: {response.status_code} - {response.text}\"\n            )\n        return []\n\n    @staticmethod\n    def projectUrl(project: OsProject):\n        return f\"https://github.com/{project.owner}/{project.id}\"\n\n    @staticmethod\n    def ticketUrl(project: OsProject):\n        return f\"https://api.github.com/repos/{project.owner}/{project.id}/issues\"\n\n    @staticmethod\n    def commitUrl(project: OsProject, id: str):\n        return f\"{GitHub.projectUrl(project)}/commit/{id}\"\n\n    @staticmethod\n    def commentUrl(project: OsProject, issue_number: int):\n        \"\"\"\n        Construct the URL for accessing comments of a specific issue.\n        \"\"\"\n        return f\"https://api.github.com/repos/{project.owner}/{project.id}/issues/{issue_number}/comments\"\n\n    @staticmethod\n    def resolveProjectUrl(url: str) -&gt; (str, str):\n        \"\"\"\n        Resolve project url to owner and project name\n\n        Returns:\n            (owner, project)\n        \"\"\"\n        # https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n        pattern = r\"((https?:\\/\\/github\\.com\\/)|(git@github\\.com:))(?P&lt;owner&gt;[^/?#]+)\\/(?P&lt;project&gt;[^\\./?#]+)(\\.git)?\"\n        match = re.match(pattern=pattern, string=url)\n        owner = match.group(\"owner\")\n        project = match.group(\"project\")\n        if owner and project:\n            return owner, project\n</code></pre>"},{"location":"#osprojects.osproject.GitHub.commentUrl","title":"<code>commentUrl(project, issue_number)</code>  <code>staticmethod</code>","text":"<p>Construct the URL for accessing comments of a specific issue.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@staticmethod\ndef commentUrl(project: OsProject, issue_number: int):\n    \"\"\"\n    Construct the URL for accessing comments of a specific issue.\n    \"\"\"\n    return f\"https://api.github.com/repos/{project.owner}/{project.id}/issues/{issue_number}/comments\"\n</code></pre>"},{"location":"#osprojects.osproject.GitHub.getComments","title":"<code>getComments(project, issue_number, access_token=None)</code>  <code>classmethod</code>","text":"<p>Fetch all comments for a specific issue number from GitHub.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef getComments(\n    cls, project: OsProject, issue_number: int, access_token: str = None\n) -&gt; List[dict]:\n    \"\"\"\n    Fetch all comments for a specific issue number from GitHub.\n    \"\"\"\n    headers = cls.prepare_headers(access_token)\n    comments_url = GitHub.commentUrl(project, issue_number)\n    response = requests.get(comments_url, headers=headers)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise Exception(\n            f\"Failed to fetch comments: {response.status_code} - {response.text}\"\n        )\n    return []\n</code></pre>"},{"location":"#osprojects.osproject.GitHub.get_project","title":"<code>get_project(owner, project_id, access_token=None)</code>  <code>classmethod</code>","text":"<p>Get a specific project as an OsProject instance.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The GitHub username or organization name.</p> required <code>project_id</code> <code>str</code> <p>The name of the project.</p> required <code>access_token</code> <code>str</code> <p>GitHub personal access token for authentication.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OsProject</code> <code>OsProject</code> <p>An OsProject instance representing the repository.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef get_project(\n    cls, owner: str, project_id: str, access_token: str = None\n) -&gt; OsProject:\n    \"\"\"\n    Get a specific project as an OsProject instance.\n\n    Args:\n        owner (str): The GitHub username or organization name.\n        project_id (str): The name of the project.\n        access_token (str, optional): GitHub personal access token for authentication.\n\n    Returns:\n        OsProject: An OsProject instance representing the repository.\n    \"\"\"\n    projects = cls.list_projects_as_os_projects(\n        owner, access_token, project_name=project_id\n    )\n    if projects:\n        return projects[0]\n    raise Exception(f\"Project {owner}/{project_id} not found\")\n</code></pre>"},{"location":"#osprojects.osproject.GitHub.list_projects_as_os_projects","title":"<code>list_projects_as_os_projects(owner, access_token=None, project_name=None)</code>  <code>classmethod</code>","text":"<p>List all public repositories for a given owner and return them as OsProject instances.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The GitHub username or organization name.</p> required <code>access_token</code> <code>str</code> <p>GitHub personal access token for authentication.</p> <code>None</code> <code>project_name</code> <code>str</code> <p>If provided, return only this specific project.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[OsProject]</code> <p>List[OsProject]: A list of OsProject instances representing the repositories.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef list_projects_as_os_projects(\n    cls, owner: str, access_token: str = None, project_name: Optional[str] = None\n) -&gt; List[OsProject]:\n    \"\"\"\n    List all public repositories for a given owner and return them as OsProject instances.\n\n    Args:\n        owner (str): The GitHub username or organization name.\n        access_token (str, optional): GitHub personal access token for authentication.\n        project_name (str, optional): If provided, return only this specific project.\n\n    Returns:\n        List[OsProject]: A list of OsProject instances representing the repositories.\n    \"\"\"\n    headers = cls.prepare_headers(access_token)\n\n    if project_name:\n        url = f\"https://api.github.com/repos/{owner}/{project_name}\"\n        response = requests.get(url, headers=headers)\n        if response.status_code != 200:\n            raise Exception(\n                f\"Failed to fetch repository: {response.status_code} - {response.text}\"\n            )\n        repos = [response.json()]\n    else:\n        url = f\"https://api.github.com/users/{owner}/repos\"\n        params = {\n            \"type\": \"all\",\n            \"per_page\": 100,\n        }  # Include all repo types, 100 per page\n        all_repos = []\n        page = 1\n\n        while True:\n            params[\"page\"] = page\n            response = requests.get(url, headers=headers, params=params)\n\n            if response.status_code != 200:\n                raise Exception(\n                    f\"Failed to fetch repositories: {response.status_code} - {response.text}\"\n                )\n\n            repos = response.json()\n            if not repos:\n                break  # No more repositories to fetch\n\n            all_repos.extend(repos)\n            page += 1\n\n        repos = all_repos\n\n    return [\n        OsProject(\n            owner=owner,\n            id=repo[\"name\"],\n            ticketSystem=cls,\n            title=repo[\"name\"],\n            url=repo[\"html_url\"],\n            description=repo[\"description\"],\n            language=repo[\"language\"],\n            created_at=datetime.datetime.fromisoformat(\n                repo[\"created_at\"].rstrip(\"Z\")\n            ),\n            updated_at=datetime.datetime.fromisoformat(\n                repo[\"updated_at\"].rstrip(\"Z\")\n            ),\n            stars=repo[\"stargazers_count\"],\n            forks=repo[\"forks_count\"],\n        )\n        for repo in repos\n    ]\n</code></pre>"},{"location":"#osprojects.osproject.GitHub.load_access_token","title":"<code>load_access_token()</code>  <code>classmethod</code>","text":"<p>if $HOME/.github/access_token.json exists read the token from there</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef load_access_token(cls) -&gt; str:\n    \"\"\"\n    if $HOME/.github/access_token.json exists read the token from there\n    \"\"\"\n    # Specify the path to the access token file\n    token_file_path = os.path.join(\n        os.getenv(\"HOME\"), \".github\", \"access_token.json\"\n    )\n\n    # Check if the file exists and read the token\n    if os.path.exists(token_file_path):\n        with open(token_file_path, \"r\") as token_file:\n            token_data = json.load(token_file)\n            return token_data.get(\"access_token\")\n\n    # Return None if no token file is found\n    return None\n</code></pre>"},{"location":"#osprojects.osproject.GitHub.prepare_headers","title":"<code>prepare_headers(access_token=None)</code>  <code>classmethod</code>","text":"<p>Prepare authorization headers for GitHub API requests.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef prepare_headers(cls, access_token: str = None) -&gt; dict:\n    \"\"\"\n    Prepare authorization headers for GitHub API requests.\n    \"\"\"\n    if access_token is None:\n        access_token = cls.load_access_token()\n\n    headers = {\"Authorization\": f\"token {access_token}\"} if access_token else {}\n    return headers\n</code></pre>"},{"location":"#osprojects.osproject.GitHub.resolveProjectUrl","title":"<code>resolveProjectUrl(url)</code>  <code>staticmethod</code>","text":"<p>Resolve project url to owner and project name</p> <p>Returns:</p> Type Description <code>(str, str)</code> <p>(owner, project)</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@staticmethod\ndef resolveProjectUrl(url: str) -&gt; (str, str):\n    \"\"\"\n    Resolve project url to owner and project name\n\n    Returns:\n        (owner, project)\n    \"\"\"\n    # https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n    pattern = r\"((https?:\\/\\/github\\.com\\/)|(git@github\\.com:))(?P&lt;owner&gt;[^/?#]+)\\/(?P&lt;project&gt;[^\\./?#]+)(\\.git)?\"\n    match = re.match(pattern=pattern, string=url)\n    owner = match.group(\"owner\")\n    project = match.group(\"project\")\n    if owner and project:\n        return owner, project\n</code></pre>"},{"location":"#osprojects.osproject.Jira","title":"<code>Jira</code>","text":"<p>               Bases: <code>TicketSystem</code></p> <p>wrapper for Jira api</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class Jira(TicketSystem):\n    \"\"\"\n    wrapper for Jira api\n    \"\"\"\n</code></pre>"},{"location":"#osprojects.osproject.OsProject","title":"<code>OsProject</code>","text":"<p>               Bases: <code>object</code></p> <p>an Open Source Project</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class OsProject(object):\n    \"\"\"\n    an Open Source Project\n    \"\"\"\n\n    def __init__(\n        self,\n        owner: str = None,\n        id: str = None,\n        ticketSystem: Type[TicketSystem] = None,\n        title: str = None,\n        url: str = None,\n        description: str = None,\n        language: str = None,\n        created_at: datetime.datetime = None,\n        updated_at: datetime.datetime = None,\n        stars: int = 0,\n        forks: int = 0,\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.owner = owner\n        self.id = id\n        self.ticketSystem = ticketSystem or GitHub\n        self.title = title\n        self.url = url\n        self.description = description\n        self.language = language\n        self.created_at = created_at\n        self.updated_at = updated_at\n        self.stars = stars\n        self.forks = forks\n\n    @property\n    def fqid(self):\n        fqid = f\"{self.owner}/{self.id}\"\n        return fqid\n\n    def __str__(self):\n        return self.fqid\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"id\": \"pyOpenSourceProjects\",\n                \"owner\": \"WolfgangFahl\",\n                \"title\": \"pyOpenSourceProjects\",\n                \"url\": \"https://github.com/WolfgangFahl/pyOpenSourceProjects\",\n                \"description\": \"Helper Library to organize open source Projects\",\n                \"language\": \"Python\",\n                \"created_at\": datetime.datetime(year=2022, month=1, day=24),\n                \"updated_at\": datetime.datetime(year=2022, month=1, day=24),\n                \"stars\": 5,\n                \"forks\": 2,\n            }\n        ]\n        return samples\n\n    @classmethod\n    def fromRepo(cls):\n        \"\"\"\n        Init OsProject from repo in current working directory\n        \"\"\"\n        url = subprocess.check_output([\"git\", \"config\", \"--get\", \"remote.origin.url\"])\n        url = url.decode().strip(\"\\n\")\n        return cls.fromUrl(url)\n\n    @classmethod\n    def fromUrl(cls, url: str) -&gt; OsProject:\n        \"\"\"\n        Init OsProject from given url\n        \"\"\"\n        if \"github.com\" in url:\n            owner, project_id = GitHub.resolveProjectUrl(url)\n            if owner and project_id:\n                github = GitHub()\n                project = github.get_project(owner, project_id)\n                return project\n        raise Exception(f\"Could not resolve the url '{url}' to a OsProject object\")\n\n    def getIssues(self, **params) -&gt; list:\n        tickets = self.ticketSystem.getIssues(self, **params)\n        tickets.sort(key=lambda r: getattr(r, \"number\"), reverse=True)\n        return tickets\n\n    def getAllTickets(self, limit: int = None, **params):\n        \"\"\"\n        Get all Tickets of the project -  closed and open ones\n\n        Args:\n            limit(int): if set limit the number of tickets retrieved\n        \"\"\"\n        issues = self.getIssues(state=\"all\", limit=limit, **params)\n        return issues\n\n    def getCommits(self) -&gt; List[Commit]:\n        commits = []\n        gitlogCmd = [\n            \"git\",\n            \"--no-pager\",\n            \"log\",\n            \"--reverse\",\n            r'--pretty=format:{\"name\":\"%cn\",\"date\":\"%cI\",\"hash\":\"%h\"}',\n        ]\n        gitLogCommitSubject = [\"git\", \"log\", \"--format=%s\", \"-n\", \"1\"]\n        rawCommitLogs = subprocess.check_output(gitlogCmd).decode()\n        for rawLog in rawCommitLogs.split(\"\\n\"):\n            log = json.loads(rawLog)\n            if log.get(\"date\", None) is not None:\n                log[\"date\"] = datetime.datetime.fromisoformat(log[\"date\"])\n            log[\"project\"] = self.id\n            log[\"host\"] = self.ticketSystem.projectUrl(self)\n            log[\"path\"] = \"\"\n            log[\"subject\"] = subprocess.check_output(\n                [*gitLogCommitSubject, log[\"hash\"]]\n            )[\n                :-1\n            ].decode()  # seperate query to avoid json escaping issues\n            commit = Commit()\n            for k, v in log.items():\n                setattr(commit, k, v)\n            commits.append(commit)\n        return commits\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.__init__","title":"<code>__init__(owner=None, id=None, ticketSystem=None, title=None, url=None, description=None, language=None, created_at=None, updated_at=None, stars=0, forks=0)</code>","text":"<p>Constructor</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def __init__(\n    self,\n    owner: str = None,\n    id: str = None,\n    ticketSystem: Type[TicketSystem] = None,\n    title: str = None,\n    url: str = None,\n    description: str = None,\n    language: str = None,\n    created_at: datetime.datetime = None,\n    updated_at: datetime.datetime = None,\n    stars: int = 0,\n    forks: int = 0,\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.owner = owner\n    self.id = id\n    self.ticketSystem = ticketSystem or GitHub\n    self.title = title\n    self.url = url\n    self.description = description\n    self.language = language\n    self.created_at = created_at\n    self.updated_at = updated_at\n    self.stars = stars\n    self.forks = forks\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.fromRepo","title":"<code>fromRepo()</code>  <code>classmethod</code>","text":"<p>Init OsProject from repo in current working directory</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef fromRepo(cls):\n    \"\"\"\n    Init OsProject from repo in current working directory\n    \"\"\"\n    url = subprocess.check_output([\"git\", \"config\", \"--get\", \"remote.origin.url\"])\n    url = url.decode().strip(\"\\n\")\n    return cls.fromUrl(url)\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.fromUrl","title":"<code>fromUrl(url)</code>  <code>classmethod</code>","text":"<p>Init OsProject from given url</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef fromUrl(cls, url: str) -&gt; OsProject:\n    \"\"\"\n    Init OsProject from given url\n    \"\"\"\n    if \"github.com\" in url:\n        owner, project_id = GitHub.resolveProjectUrl(url)\n        if owner and project_id:\n            github = GitHub()\n            project = github.get_project(owner, project_id)\n            return project\n    raise Exception(f\"Could not resolve the url '{url}' to a OsProject object\")\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.getAllTickets","title":"<code>getAllTickets(limit=None, **params)</code>","text":"<p>Get all Tickets of the project -  closed and open ones</p> <p>Parameters:</p> Name Type Description Default <code>limit(int)</code> <p>if set limit the number of tickets retrieved</p> required Source code in <code>osprojects/osproject.py</code> <pre><code>def getAllTickets(self, limit: int = None, **params):\n    \"\"\"\n    Get all Tickets of the project -  closed and open ones\n\n    Args:\n        limit(int): if set limit the number of tickets retrieved\n    \"\"\"\n    issues = self.getIssues(state=\"all\", limit=limit, **params)\n    return issues\n</code></pre>"},{"location":"#osprojects.osproject.Ticket","title":"<code>Ticket</code>","text":"<p>               Bases: <code>object</code></p> <p>a Ticket</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class Ticket(object):\n    \"\"\"\n    a Ticket\n    \"\"\"\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"number\": 2,\n                \"title\": \"Get Tickets in Wiki notation from github API\",\n                \"createdAt\": datetime.datetime.fromisoformat(\n                    \"2022-01-24 07:41:29+00:00\"\n                ),\n                \"closedAt\": datetime.datetime.fromisoformat(\n                    \"2022-01-25 07:43:04+00:00\"\n                ),\n                \"url\": \"https://github.com/WolfgangFahl/pyOpenSourceProjects/issues/2\",\n                \"project\": \"pyOpenSourceProjects\",\n                \"state\": \"closed\",\n            }\n        ]\n        return samples\n\n    @classmethod\n    def init_from_dict(cls, **records):\n        \"\"\"\n        inits Ticket from given args\n        \"\"\"\n        issue = Ticket()\n        for k, v in records.items():\n            setattr(issue, k, v)\n        return issue\n\n    def toWikiMarkup(self) -&gt; str:\n        \"\"\"\n        Returns Ticket in wiki markup\n        \"\"\"\n        return f\"\"\"# {{{{Ticket\n|number={self.number}\n|title={self.title}\n|project={self.project.id}\n|createdAt={self.createdAt if self.createdAt else \"\"}\n|closedAt={self.closedAt if self.closedAt else \"\"}\n|state={self.state}\n}}}}\"\"\"\n</code></pre>"},{"location":"#osprojects.osproject.Ticket.init_from_dict","title":"<code>init_from_dict(**records)</code>  <code>classmethod</code>","text":"<p>inits Ticket from given args</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef init_from_dict(cls, **records):\n    \"\"\"\n    inits Ticket from given args\n    \"\"\"\n    issue = Ticket()\n    for k, v in records.items():\n        setattr(issue, k, v)\n    return issue\n</code></pre>"},{"location":"#osprojects.osproject.Ticket.toWikiMarkup","title":"<code>toWikiMarkup()</code>","text":"<p>Returns Ticket in wiki markup</p> Source code in <code>osprojects/osproject.py</code> <pre><code>    def toWikiMarkup(self) -&gt; str:\n        \"\"\"\n        Returns Ticket in wiki markup\n        \"\"\"\n        return f\"\"\"# {{{{Ticket\n|number={self.number}\n|title={self.title}\n|project={self.project.id}\n|createdAt={self.createdAt if self.createdAt else \"\"}\n|closedAt={self.closedAt if self.closedAt else \"\"}\n|state={self.state}\n}}}}\"\"\"\n</code></pre>"},{"location":"#osprojects.osproject.TicketSystem","title":"<code>TicketSystem</code>","text":"<p>               Bases: <code>object</code></p> <p>platform for hosting OpenSourceProjects and their issues</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class TicketSystem(object):\n    \"\"\"\n    platform for hosting OpenSourceProjects and their issues\n    \"\"\"\n\n    @classmethod\n    def getIssues(self, project: OsProject, **kwargs) -&gt; List[Ticket]:\n        \"\"\"\n        get issues from the TicketSystem for a project\n        \"\"\"\n        return NotImplemented\n\n    @staticmethod\n    def projectUrl(project: OsProject):\n        \"\"\"\n        url of the project\n        \"\"\"\n        return NotImplemented\n\n    @staticmethod\n    def ticketUrl(project: OsProject):\n        \"\"\"\n        url of the ticket/issue list\n        \"\"\"\n        return NotImplemented\n\n    @staticmethod\n    def commitUrl(project: OsProject, id: str):\n        \"\"\"\n        url of the ticket/issue list\n        \"\"\"\n        return NotImplemented\n</code></pre>"},{"location":"#osprojects.osproject.TicketSystem.commitUrl","title":"<code>commitUrl(project, id)</code>  <code>staticmethod</code>","text":"<p>url of the ticket/issue list</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@staticmethod\ndef commitUrl(project: OsProject, id: str):\n    \"\"\"\n    url of the ticket/issue list\n    \"\"\"\n    return NotImplemented\n</code></pre>"},{"location":"#osprojects.osproject.TicketSystem.getIssues","title":"<code>getIssues(project, **kwargs)</code>  <code>classmethod</code>","text":"<p>get issues from the TicketSystem for a project</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef getIssues(self, project: OsProject, **kwargs) -&gt; List[Ticket]:\n    \"\"\"\n    get issues from the TicketSystem for a project\n    \"\"\"\n    return NotImplemented\n</code></pre>"},{"location":"#osprojects.osproject.TicketSystem.projectUrl","title":"<code>projectUrl(project)</code>  <code>staticmethod</code>","text":"<p>url of the project</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@staticmethod\ndef projectUrl(project: OsProject):\n    \"\"\"\n    url of the project\n    \"\"\"\n    return NotImplemented\n</code></pre>"},{"location":"#osprojects.osproject.TicketSystem.ticketUrl","title":"<code>ticketUrl(project)</code>  <code>staticmethod</code>","text":"<p>url of the ticket/issue list</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@staticmethod\ndef ticketUrl(project: OsProject):\n    \"\"\"\n    url of the ticket/issue list\n    \"\"\"\n    return NotImplemented\n</code></pre>"},{"location":"#osprojects.osproject.gitlog2wiki","title":"<code>gitlog2wiki(_argv=None)</code>","text":"<p>cmdline interface to get gitlog entries in wiki markup</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def gitlog2wiki(_argv=None):\n    \"\"\"\n    cmdline interface to get gitlog entries in wiki markup\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"gitlog2wiki\")\n    if _argv:\n        _args = parser.parse_args(args=_argv)\n\n    osProject = OsProject.fromRepo()\n    commits = osProject.getCommits()\n    print(\"\\n\".join([c.toWikiMarkup() for c in commits]))\n</code></pre>"},{"location":"#osprojects.osproject.main","title":"<code>main(_argv=None)</code>","text":"<p>main command line entry point</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def main(_argv=None):\n    \"\"\"\n    main command line entry point\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Issue2ticket\")\n    parser.add_argument(\"-o\", \"--owner\", help=\"project owner or organization\")\n    parser.add_argument(\"-p\", \"--project\", help=\"name of the project\")\n    parser.add_argument(\n        \"--repo\",\n        action=\"store_true\",\n        help=\"get needed information form repository of current location\",\n    )\n    parser.add_argument(\n        \"-ts\",\n        \"--ticketsystem\",\n        default=\"github\",\n        choices=[\"github\", \"jira\"],\n        help=\"platform the project is hosted\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--state\",\n        choices=[\"open\", \"closed\", \"all\"],\n        default=\"all\",\n        help=\"only issues with the given state\",\n    )\n    parser.add_argument(\"-V\", \"--version\", action=\"version\", version=\"gitlog2wiki 0.1\")\n\n    args = parser.parse_args(args=_argv)\n    # resolve ticketsystem\n    ticketSystem = GitHub\n    if args.ticketsystem == \"jira\":\n        ticketSystem = Jira\n    if args.project and args.owner:\n        osProject = OsProject(\n            owner=args.owner, id=args.project, ticketSystem=ticketSystem\n        )\n    else:\n        osProject = OsProject.fromRepo()\n    tickets = osProject.getIssues(state=args.state)\n    print(\"\\n\".join([t.toWikiMarkup() for t in tickets]))\n</code></pre>"}]}