{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyOpenSourceProjects API Documentation","text":""},{"location":"#osprojects.check_project","title":"<code>check_project</code>","text":"<p>Created on 2024-08-28.</p> <p>@author: wf</p>"},{"location":"#osprojects.check_project.CheckProject","title":"<code>CheckProject</code>","text":"<p>Checker for an individual open source project.</p> Source code in <code>osprojects/check_project.py</code> <pre><code>class CheckProject:\n    \"\"\"Checker for an individual open source project.\"\"\"\n\n    def __init__(self, parent, project, args):\n        self.parent = parent\n        self.project = project\n        self.args = args\n        self.checks: List[Check] = []\n        self.project_path = project.folder\n        self.project_name = None\n        self.requires_python = None\n        self.min_python_version_minor = None\n        self.max_python_version_minor = 13  # python 3.13 is max version\n\n    @property\n    def total(self) -&gt; int:\n        return len(self.checks)\n\n    @property\n    def ok_checks(self) -&gt; List[Check]:\n        ok_checks = [check for check in self.checks if check.ok]\n        return ok_checks\n\n    @property\n    def failed_checks(self) -&gt; List[Check]:\n        failed_checks = [check for check in self.checks if not check.ok]\n        return failed_checks\n\n    def add_error(self, ex, path: str):\n        self.parent.handle_exception(ex)\n        self.add_check(False, msg=f\"{str(ex)}\", path=path)\n\n    def add_check(\n        self, ok, msg: str = \"\", path: str = None, negative: bool = False\n    ) -&gt; Check:\n        if not path:\n            raise ValueError(\"path parameter missing\")\n        marker = \"\"\n        if negative:\n            ok = not ok\n            marker = \"\u26a0 \ufe0f\"\n        check = Check(ok=ok, path=path, msg=f\"{marker}{msg}{path}\")\n        self.checks.append(check)\n        return check\n\n    def add_content_check(\n        self, content: str, needle: str, path: str, negative: bool = False\n    ) -&gt; Check:\n        ok = needle in content\n        check = self.add_check(ok, msg=f\"{needle} in \", path=path, negative=negative)\n        return check\n\n    def add_path_check(self, path) -&gt; Check:\n        # Check if path exists\n        path_exists = Check.file_exists(path)\n        self.checks.append(path_exists)\n        return path_exists\n\n    def check_local(self) -&gt; Check:\n        local = Check.file_exists(self.project_path)\n        return local\n\n    def check_github_workflows(self):\n        \"\"\"Check the github workflow files.\"\"\"\n        workflows_path = os.path.join(self.project_path, \".github\", \"workflows\")\n        workflows_exist = self.add_path_check(workflows_path)\n\n        if workflows_exist.ok:\n            required_files = [\"build.yml\", \"upload-to-pypi.yml\"]\n            for file in required_files:\n                file_path = os.path.join(workflows_path, file)\n                file_exists = self.add_path_check(file_path)\n\n                if file_exists.ok:\n                    content = file_exists.content\n\n                    if file == \"build.yml\":\n                        min_python_version_minor = int(\n                            self.requires_python.split(\".\")[-1]\n                        )\n                        self.add_check(\n                            min_python_version_minor == self.min_python_version_minor,\n                            msg=f\"{min_python_version_minor} (build.yml)!={self.min_python_version_minor} (pyprojec.toml)\",\n                            path=file_path,\n                        )\n                        python_versions = f\"\"\"python-version: [ {', '.join([f\"'3.{i}'\" for i in range(self.min_python_version_minor, self.max_python_version_minor+1)])} ]\"\"\"\n                        self.add_content_check(\n                            content,\n                            python_versions,\n                            file_path,\n                        )\n                        self.add_content_check(\n                            content,\n                            \"os: [ubuntu-latest, macos-latest, windows-latest]\",\n                            file_path,\n                        )\n                        self.add_content_check(\n                            content, \"uses: actions/checkout@v4\", file_path\n                        )\n                        self.add_content_check(\n                            content,\n                            \"uses: actions/setup-python@v5\",\n                            file_path,\n                        )\n\n                        self.add_content_check(\n                            content, \"sphinx\", file_path, negative=True\n                        )\n                        scripts_ok = (\n                            \"scripts/install\" in content\n                            and \"scripts/test\" in content\n                            or \"scripts/installAndTest\" in content\n                        )\n                        self.add_check(scripts_ok, \"install and test\", file_path)\n\n                    elif file == \"upload-to-pypi.yml\":\n                        self.add_content_check(content, \"id-token: write\", file_path)\n                        self.add_content_check(\n                            content, \"uses: actions/checkout@v4\", file_path\n                        )\n                        self.add_content_check(\n                            content,\n                            \"uses: actions/setup-python@v5\",\n                            file_path,\n                        )\n                        self.add_content_check(\n                            content,\n                            \"uses: pypa/gh-action-pypi-publish@release/v1\",\n                            file_path,\n                        )\n\n    def check_scripts(self):\n        scripts_path = os.path.join(self.project_path, \"scripts\")\n        scripts_exist = self.add_path_check(scripts_path)\n        if scripts_exist.ok:\n            required_files = [\"blackisort\", \"test\", \"install\", \"doc\", \"release\"]\n            for file in required_files:\n                file_path = os.path.join(scripts_path, file)\n                file_exists = self.add_path_check(file_path)\n                if file_exists.ok:\n                    content = file_exists.content\n                    if file == \"doc\":\n                        self.add_content_check(\n                            content, \"sphinx\", file_path, negative=True\n                        )\n                        self.add_content_check(\n                            content, \"WF 2024-07-30 - updated\", file_path\n                        )\n                    if file == \"test\":\n                        self.add_content_check(content, \"WF 2024-08-03\", file_path)\n                    if file == \"release\":\n                        self.add_content_check(content, \"scripts/doc -d\", file_path)\n\n    def check_readme(self):\n        readme_path = os.path.join(self.project_path, \"README.md\")\n        readme_exists = self.add_path_check(readme_path)\n        if not hasattr(self, \"project_name\"):\n            self.add_check(\n                False,\n                \"project_name from pyproject.toml needed for README.md check\",\n                self.project_path,\n            )\n            return\n        if readme_exists.ok:\n            readme_content = readme_exists.content\n            badge_lines = [\n                \"[![pypi](https://img.shields.io/pypi/pyversions/{self.project_name})](https://pypi.org/project/{self.project_name}/)\",\n                \"[![Github Actions Build](https://github.com/{self.project.fqid}/actions/workflows/build.yml/badge.svg)](https://github.com/{self.project.fqid}/actions/workflows/build.yml)\",\n                \"[![PyPI Status](https://img.shields.io/pypi/v/{self.project_name}.svg)](https://pypi.python.org/pypi/{self.project_name}/)\",\n                \"[![GitHub issues](https://img.shields.io/github/issues/{self.project.fqid}.svg)](https://github.com/{self.project.fqid}/issues)\",\n                \"[![GitHub closed issues](https://img.shields.io/github/issues-closed/{self.project.fqid}.svg)](https://github.com/{self.project.fqid}/issues/?q=is%3Aissue+is%3Aclosed)\",\n                \"[![API Docs](https://img.shields.io/badge/API-Documentation-blue)](https://{self.project.owner}.github.io/{self.project.project_id}/)\",\n                \"[![License](https://img.shields.io/github/license/{self.project.fqid}.svg)](https://www.apache.org/licenses/LICENSE-2.0)\",\n            ]\n            for line in badge_lines:\n                formatted_line = line.format(self=self)\n                self.add_content_check(\n                    content=readme_content,\n                    needle=formatted_line,\n                    path=readme_path,\n                )\n            self.add_content_check(\n                readme_content, \"readthedocs\", readme_path, negative=True\n            )\n\n    def check_pyproject_toml(self) -&gt; bool:\n        \"\"\"pyproject.toml.\"\"\"\n        toml_path = os.path.join(self.project_path, \"pyproject.toml\")\n        toml_exists = self.add_path_check(toml_path)\n        if toml_exists.ok:\n            content = toml_exists.content\n            toml_dict = tomllib.loads(content)\n            project_check = self.add_check(\n                \"project\" in toml_dict, \"[project]\", toml_path\n            )\n            if project_check.ok:\n                self.project_name = toml_dict[\"project\"][\"name\"]\n                requires_python_check = self.add_check(\n                    \"requires-python\" in toml_dict[\"project\"],\n                    \"requires-python\",\n                    toml_path,\n                )\n                if requires_python_check.ok:\n                    self.requires_python = toml_dict[\"project\"][\"requires-python\"]\n                    min_python_version = version.parse(\n                        self.requires_python.replace(\"&gt;=\", \"\")\n                    )\n                    min_version_needed = \"3.9\"\n                    version_ok = min_python_version &gt;= version.parse(min_version_needed)\n                    self.add_check(\n                        version_ok, f\"requires-python&gt;={min_version_needed}\", toml_path\n                    )\n                    self.min_python_version_minor = int(\n                        str(min_python_version).split(\".\")[-1]\n                    )\n                    for minor_version in range(\n                        self.min_python_version_minor, self.max_python_version_minor + 1\n                    ):\n                        needle = f\"Programming Language :: Python :: 3.{minor_version}\"\n                        self.add_content_check(content, needle, toml_path)\n            self.add_content_check(content, \"hatchling\", toml_path)\n            self.add_content_check(\n                content, \"[tool.hatch.build.targets.wheel.sources]\", toml_path\n            )\n        return toml_exists.ok\n\n    def check_git(self) -&gt; bool:\n        \"\"\"Check git repository information using GitHub class.\n\n        Returns:\n            bool: True if git owner matches project owner and the repo is not a fork\n        \"\"\"\n        owner_match = False\n        is_fork = False\n        try:\n            local_owner = self.project.owner\n            remote_owner = self.project.repo_info[\"owner\"][\"login\"]\n            is_fork = self.project.repo_info[\"fork\"]\n            owner_match = local_owner.lower() == remote_owner.lower() and not is_fork\n            self.add_check(\n                owner_match,\n                f\"Git owner ({remote_owner}) matches project owner ({local_owner}) and is not a fork\",\n                self.project_path,\n            )\n\n            local_project_id = self.project.project_id\n            remote_repo_name = self.project.repo_info[\"name\"]\n            repo_match = local_project_id.lower() == remote_repo_name.lower()\n            self.add_check(\n                repo_match,\n                f\"Git repo name ({remote_repo_name}) matches project id ({local_project_id})\",\n                self.project_path,\n            )\n\n            # Check if there are uncommitted changes (this still requires local git access)\n            local_repo = Repo(self.project_path)\n            self.add_check(\n                not local_repo.is_dirty(), \"uncomitted changes for\", self.project_path\n            )\n\n            # Check latest GitHub Actions workflow run\n            latest_run = GitHubAction.get_latest_workflow_run(self.project)\n            if latest_run:\n                self.add_check(\n                    latest_run[\"conclusion\"] == \"success\",\n                    f\"Latest GitHub Actions run: {latest_run['conclusion']}\",\n                    latest_run[\"html_url\"],\n                )\n            else:\n                self.add_check(\n                    False,\n                    \"No GitHub Actions runs found\",\n                    self.project.repo.ticketUrl(),\n                )\n\n        except InvalidGitRepositoryError:\n            self.add_check(False, \"Not a valid git repository\", self.project_path)\n        except NoSuchPathError:\n            self.add_check(\n                False, \"Git repository path does not exist\", self.project_path\n            )\n        except Exception as ex:\n            self.add_error(ex, self.project_path)\n\n        return owner_match and not is_fork\n\n    def check(self, title: str):\n        \"\"\"Check the given project and print results.\"\"\"\n        self.check_local()\n        self.check_git()\n        if self.check_pyproject_toml():\n            self.check_github_workflows()\n            self.check_readme()\n            self.check_scripts()\n\n        # ok_count=len(ok_checks)\n        failed_count = len(self.failed_checks)\n        summary = (\n            f\"\u274c {failed_count:2}/{self.total:2}\"\n            if failed_count &gt; 0\n            else f\"\u2705 {self.total:2}/{self.total:2}\"\n        )\n        print(f\"{title}{summary}:{self.project}\u2192{self.project.url}\")\n        if failed_count &gt; 0:\n            # Sort checks by path\n            sorted_checks = sorted(self.checks, key=lambda c: c.path or \"\")\n\n            # Group checks by path\n            checks_by_path = {}\n            for check in sorted_checks:\n                if check.path not in checks_by_path:\n                    checks_by_path[check.path] = []\n                checks_by_path[check.path].append(check)\n\n            # Display results\n            for path, path_checks in checks_by_path.items():\n                path_failed = sum(1 for c in path_checks if not c.ok)\n                if path_failed &gt; 0 or self.args.debug:\n                    print(f\"\u274c {path}: {path_failed}\")\n                    i = 0\n                    for check in path_checks:\n                        show = not check.ok or self.args.debug\n                        if show:\n                            i += 1\n                            print(f\"    {i:3}{check.marker}:{check.msg}\")\n\n                    if self.args.editor and path_failed &gt; 0:\n                        if os.path.isfile(path):\n                            # @TODO Make editor configurable\n                            Editor.open(path, default_editor_cmd=\"/usr/local/bin/atom\")\n                        else:\n                            Editor.open_filepath(path)\n</code></pre>"},{"location":"#osprojects.check_project.CheckProject.check","title":"<code>check(title)</code>","text":"<p>Check the given project and print results.</p> Source code in <code>osprojects/check_project.py</code> <pre><code>def check(self, title: str):\n    \"\"\"Check the given project and print results.\"\"\"\n    self.check_local()\n    self.check_git()\n    if self.check_pyproject_toml():\n        self.check_github_workflows()\n        self.check_readme()\n        self.check_scripts()\n\n    # ok_count=len(ok_checks)\n    failed_count = len(self.failed_checks)\n    summary = (\n        f\"\u274c {failed_count:2}/{self.total:2}\"\n        if failed_count &gt; 0\n        else f\"\u2705 {self.total:2}/{self.total:2}\"\n    )\n    print(f\"{title}{summary}:{self.project}\u2192{self.project.url}\")\n    if failed_count &gt; 0:\n        # Sort checks by path\n        sorted_checks = sorted(self.checks, key=lambda c: c.path or \"\")\n\n        # Group checks by path\n        checks_by_path = {}\n        for check in sorted_checks:\n            if check.path not in checks_by_path:\n                checks_by_path[check.path] = []\n            checks_by_path[check.path].append(check)\n\n        # Display results\n        for path, path_checks in checks_by_path.items():\n            path_failed = sum(1 for c in path_checks if not c.ok)\n            if path_failed &gt; 0 or self.args.debug:\n                print(f\"\u274c {path}: {path_failed}\")\n                i = 0\n                for check in path_checks:\n                    show = not check.ok or self.args.debug\n                    if show:\n                        i += 1\n                        print(f\"    {i:3}{check.marker}:{check.msg}\")\n\n                if self.args.editor and path_failed &gt; 0:\n                    if os.path.isfile(path):\n                        # @TODO Make editor configurable\n                        Editor.open(path, default_editor_cmd=\"/usr/local/bin/atom\")\n                    else:\n                        Editor.open_filepath(path)\n</code></pre>"},{"location":"#osprojects.check_project.CheckProject.check_git","title":"<code>check_git()</code>","text":"<p>Check git repository information using GitHub class.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if git owner matches project owner and the repo is not a fork</p> Source code in <code>osprojects/check_project.py</code> <pre><code>def check_git(self) -&gt; bool:\n    \"\"\"Check git repository information using GitHub class.\n\n    Returns:\n        bool: True if git owner matches project owner and the repo is not a fork\n    \"\"\"\n    owner_match = False\n    is_fork = False\n    try:\n        local_owner = self.project.owner\n        remote_owner = self.project.repo_info[\"owner\"][\"login\"]\n        is_fork = self.project.repo_info[\"fork\"]\n        owner_match = local_owner.lower() == remote_owner.lower() and not is_fork\n        self.add_check(\n            owner_match,\n            f\"Git owner ({remote_owner}) matches project owner ({local_owner}) and is not a fork\",\n            self.project_path,\n        )\n\n        local_project_id = self.project.project_id\n        remote_repo_name = self.project.repo_info[\"name\"]\n        repo_match = local_project_id.lower() == remote_repo_name.lower()\n        self.add_check(\n            repo_match,\n            f\"Git repo name ({remote_repo_name}) matches project id ({local_project_id})\",\n            self.project_path,\n        )\n\n        # Check if there are uncommitted changes (this still requires local git access)\n        local_repo = Repo(self.project_path)\n        self.add_check(\n            not local_repo.is_dirty(), \"uncomitted changes for\", self.project_path\n        )\n\n        # Check latest GitHub Actions workflow run\n        latest_run = GitHubAction.get_latest_workflow_run(self.project)\n        if latest_run:\n            self.add_check(\n                latest_run[\"conclusion\"] == \"success\",\n                f\"Latest GitHub Actions run: {latest_run['conclusion']}\",\n                latest_run[\"html_url\"],\n            )\n        else:\n            self.add_check(\n                False,\n                \"No GitHub Actions runs found\",\n                self.project.repo.ticketUrl(),\n            )\n\n    except InvalidGitRepositoryError:\n        self.add_check(False, \"Not a valid git repository\", self.project_path)\n    except NoSuchPathError:\n        self.add_check(\n            False, \"Git repository path does not exist\", self.project_path\n        )\n    except Exception as ex:\n        self.add_error(ex, self.project_path)\n\n    return owner_match and not is_fork\n</code></pre>"},{"location":"#osprojects.check_project.CheckProject.check_github_workflows","title":"<code>check_github_workflows()</code>","text":"<p>Check the github workflow files.</p> Source code in <code>osprojects/check_project.py</code> <pre><code>def check_github_workflows(self):\n    \"\"\"Check the github workflow files.\"\"\"\n    workflows_path = os.path.join(self.project_path, \".github\", \"workflows\")\n    workflows_exist = self.add_path_check(workflows_path)\n\n    if workflows_exist.ok:\n        required_files = [\"build.yml\", \"upload-to-pypi.yml\"]\n        for file in required_files:\n            file_path = os.path.join(workflows_path, file)\n            file_exists = self.add_path_check(file_path)\n\n            if file_exists.ok:\n                content = file_exists.content\n\n                if file == \"build.yml\":\n                    min_python_version_minor = int(\n                        self.requires_python.split(\".\")[-1]\n                    )\n                    self.add_check(\n                        min_python_version_minor == self.min_python_version_minor,\n                        msg=f\"{min_python_version_minor} (build.yml)!={self.min_python_version_minor} (pyprojec.toml)\",\n                        path=file_path,\n                    )\n                    python_versions = f\"\"\"python-version: [ {', '.join([f\"'3.{i}'\" for i in range(self.min_python_version_minor, self.max_python_version_minor+1)])} ]\"\"\"\n                    self.add_content_check(\n                        content,\n                        python_versions,\n                        file_path,\n                    )\n                    self.add_content_check(\n                        content,\n                        \"os: [ubuntu-latest, macos-latest, windows-latest]\",\n                        file_path,\n                    )\n                    self.add_content_check(\n                        content, \"uses: actions/checkout@v4\", file_path\n                    )\n                    self.add_content_check(\n                        content,\n                        \"uses: actions/setup-python@v5\",\n                        file_path,\n                    )\n\n                    self.add_content_check(\n                        content, \"sphinx\", file_path, negative=True\n                    )\n                    scripts_ok = (\n                        \"scripts/install\" in content\n                        and \"scripts/test\" in content\n                        or \"scripts/installAndTest\" in content\n                    )\n                    self.add_check(scripts_ok, \"install and test\", file_path)\n\n                elif file == \"upload-to-pypi.yml\":\n                    self.add_content_check(content, \"id-token: write\", file_path)\n                    self.add_content_check(\n                        content, \"uses: actions/checkout@v4\", file_path\n                    )\n                    self.add_content_check(\n                        content,\n                        \"uses: actions/setup-python@v5\",\n                        file_path,\n                    )\n                    self.add_content_check(\n                        content,\n                        \"uses: pypa/gh-action-pypi-publish@release/v1\",\n                        file_path,\n                    )\n</code></pre>"},{"location":"#osprojects.check_project.CheckProject.check_pyproject_toml","title":"<code>check_pyproject_toml()</code>","text":"<p>pyproject.toml.</p> Source code in <code>osprojects/check_project.py</code> <pre><code>def check_pyproject_toml(self) -&gt; bool:\n    \"\"\"pyproject.toml.\"\"\"\n    toml_path = os.path.join(self.project_path, \"pyproject.toml\")\n    toml_exists = self.add_path_check(toml_path)\n    if toml_exists.ok:\n        content = toml_exists.content\n        toml_dict = tomllib.loads(content)\n        project_check = self.add_check(\n            \"project\" in toml_dict, \"[project]\", toml_path\n        )\n        if project_check.ok:\n            self.project_name = toml_dict[\"project\"][\"name\"]\n            requires_python_check = self.add_check(\n                \"requires-python\" in toml_dict[\"project\"],\n                \"requires-python\",\n                toml_path,\n            )\n            if requires_python_check.ok:\n                self.requires_python = toml_dict[\"project\"][\"requires-python\"]\n                min_python_version = version.parse(\n                    self.requires_python.replace(\"&gt;=\", \"\")\n                )\n                min_version_needed = \"3.9\"\n                version_ok = min_python_version &gt;= version.parse(min_version_needed)\n                self.add_check(\n                    version_ok, f\"requires-python&gt;={min_version_needed}\", toml_path\n                )\n                self.min_python_version_minor = int(\n                    str(min_python_version).split(\".\")[-1]\n                )\n                for minor_version in range(\n                    self.min_python_version_minor, self.max_python_version_minor + 1\n                ):\n                    needle = f\"Programming Language :: Python :: 3.{minor_version}\"\n                    self.add_content_check(content, needle, toml_path)\n        self.add_content_check(content, \"hatchling\", toml_path)\n        self.add_content_check(\n            content, \"[tool.hatch.build.targets.wheel.sources]\", toml_path\n        )\n    return toml_exists.ok\n</code></pre>"},{"location":"#osprojects.checkos","title":"<code>checkos</code>","text":"<p>Created on 2024-07-30.</p> <p>@author: wf</p>"},{"location":"#osprojects.checkos.CheckOS","title":"<code>CheckOS</code>","text":"<p>Checker for a set of open source projects.</p> Source code in <code>osprojects/checkos.py</code> <pre><code>class CheckOS:\n    \"\"\"Checker for a set of open source projects.\"\"\"\n\n    def __init__(\n        self, args: Namespace, osprojects: OsProjects, max_python_version_minor=12\n    ):\n        self.args = args\n        self.verbose = args.verbose\n        self.workspace = args.workspace\n        self.osprojects = osprojects\n        self.checks = []\n        # python 3.12 is max version\n        self.max_python_version_minor = max_python_version_minor\n\n    @classmethod\n    def from_args(cls, args: Namespace):\n        osprojects = OsProjects.from_folder(args.workspace, with_progress=True)\n        return cls(args, osprojects)\n\n    def select_projects(self):\n        try:\n            if self.args.project:\n                if self.args.owners:\n                    return self.osprojects.select_projects(\n                        owners=self.args.owners, project_id=self.args.project\n                    )\n                elif self.args.local:\n                    return self.osprojects.select_projects(\n                        project_id=self.args.project, local_only=True\n                    )\n                else:\n                    raise ValueError(\"--local or --owner needed with --project\")\n            elif self.args.owners:\n                return self.osprojects.select_projects(owners=self.args.owners)\n            elif self.args.local:\n                return self.osprojects.select_projects(local_only=True)\n            else:\n                raise ValueError(\n                    \"Please provide --owner and --project, or use --local option.\"\n                )\n        except ValueError as e:\n            print(f\"Error: {str(e)}\")\n            return []\n\n    def filter_projects(self):\n        if self.args.language:\n            self.osprojects.filter_projects(language=self.args.language)\n        if self.args.local:\n            self.osprojects.filter_projects(local_only=True)\n\n    def check_projects(self):\n        \"\"\"Select, filter, and check all projects based on the provided\n        arguments.\"\"\"\n        self.select_projects()\n        self.filter_projects()\n\n        for i, (_url, project) in enumerate(\n            self.osprojects.selected_projects.items(), 1\n        ):\n            checker = CheckProject(self, project, self.args)\n            checker.check(f\"{i:3}:\")\n\n    def handle_exception(self, ex: Exception):\n        CheckOS.show_exception(ex, self.args.debug)\n\n    @staticmethod\n    def show_exception(ex: Exception, debug: bool = False):\n        err_msg = f\"Error: {str(ex)}\"\n        logging.error(err_msg)\n        if debug:\n            print(traceback.format_exc())\n</code></pre>"},{"location":"#osprojects.checkos.CheckOS.check_projects","title":"<code>check_projects()</code>","text":"<p>Select, filter, and check all projects based on the provided arguments.</p> Source code in <code>osprojects/checkos.py</code> <pre><code>def check_projects(self):\n    \"\"\"Select, filter, and check all projects based on the provided\n    arguments.\"\"\"\n    self.select_projects()\n    self.filter_projects()\n\n    for i, (_url, project) in enumerate(\n        self.osprojects.selected_projects.items(), 1\n    ):\n        checker = CheckProject(self, project, self.args)\n        checker.check(f\"{i:3}:\")\n</code></pre>"},{"location":"#osprojects.checkos.main","title":"<code>main(_argv=None)</code>","text":"<p>Main command line entry point.</p> Source code in <code>osprojects/checkos.py</code> <pre><code>def main(_argv=None):\n    \"\"\"Main command line entry point.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Check open source projects\")\n    parser.add_argument(\n        \"-d\",\n        \"--debug\",\n        action=\"store_true\",\n        help=\"add debug output\",\n    )\n    parser.add_argument(\n        \"-e\",\n        \"--editor\",\n        action=\"store_true\",\n        help=\"open default editor on failed files\",\n    )\n    parser.add_argument(\"-o\", \"--owners\", nargs=\"+\", help=\"project owners\")\n    parser.add_argument(\"-p\", \"--project\", help=\"name of the project\")\n    parser.add_argument(\"-l\", \"--language\", help=\"filter projects by language\")\n    parser.add_argument(\n        \"--local\", action=\"store_true\", help=\"check only locally available projects\"\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\", action=\"store_true\", help=\"show verbose output\"\n    )\n    parser.add_argument(\n        \"-ws\",\n        \"--workspace\",\n        help=\"(Eclipse) workspace directory\",\n        default=os.path.expanduser(\"~/py-workspace\"),\n    )\n\n    args = parser.parse_args(args=_argv)\n\n    try:\n        checker = CheckOS.from_args(args)\n        checker.check_projects()\n    except Exception as ex:\n        CheckOS.show_exception(ex, debug=args.debug)\n        raise ex\n</code></pre>"},{"location":"#osprojects.editor","title":"<code>editor</code>","text":"<p>Created on 2022-11-27.</p> <p>@author: wf</p>"},{"location":"#osprojects.editor.Editor","title":"<code>Editor</code>","text":"<p>Helper class to open the system defined editor.</p> <p>see https://stackoverflow.com/questions/1442841/lauch-default-editor-like-webbrowser-module</p> Source code in <code>osprojects/editor.py</code> <pre><code>class Editor:\n    \"\"\"Helper class to open the system defined editor.\n\n    see\n    https://stackoverflow.com/questions/1442841/lauch-default-editor-like-webbrowser-module\n    \"\"\"\n\n    @classmethod\n    def open_filepath(cls, filepath: str):\n        if platform.system() == \"Darwin\":  # macOS\n            subprocess.call((\"open\", filepath))\n        elif platform.system() == \"Windows\":  # Windows\n            os.startfile(filepath, \"open\")\n        else:  # linux variants\n            subprocess.call((\"xdg-open\", filepath))\n\n    @classmethod\n    def extract_text(cls, html_text: str) -&gt; str:\n        \"\"\"Extract the text from the given html_text.\n\n        Args:\n            html_text(str): the input for the html text\n\n        Returns:\n            str: the plain text\n        \"\"\"\n        soup = BeautifulSoup(html_text, features=\"html.parser\")\n\n        # kill all script and style elements\n        for script in soup([\"script\", \"style\"]):\n            script.extract()  # rip it out\n\n        # get text\n        text = soup.get_text()\n\n        # break into lines and remove leading and trailing space on each\n        lines = (line.strip() for line in text.splitlines())\n        # break multi-headlines into a line each\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n        # drop blank lines\n        text = \"\\n\".join(chunk for chunk in chunks if chunk)\n        return text\n\n    @classmethod\n    def open(\n        cls,\n        file_source: str,\n        extract_text: bool = True,\n        default_editor_cmd: str = \"/usr/local/bin/atom\",\n    ) -&gt; str:\n        \"\"\"Open an editor for the given file_source.\n\n        Args:\n            file_source(str): the path to the file\n            extract_text(bool): if True extract the text from html sources\n\n        Returns:\n            str: the path to the file e.g. a temporary file if the file_source points to an url\n        \"\"\"\n        # handle urls\n        # https://stackoverflow.com/a/45886824/1497139\n        if file_source.startswith(\"http\"):\n            url_source = urlopen(file_source)\n            # https://stackoverflow.com/a/19156107/1497139\n            charset = url_source.headers.get_content_charset()\n            # if charset fails here you might want to set it to utf-8 as a default!\n            text = url_source.read().decode(charset)\n            if extract_text:\n                # https://stackoverflow.com/a/24618186/1497139\n                text = cls.extract_text(text)\n\n            return cls.open_tmp_text(text)\n\n        editor_cmd = None\n        editor_env = os.getenv(\"EDITOR\")\n        if editor_env:\n            editor_cmd = editor_env\n        if platform.system() == \"Darwin\":\n            if not editor_env:\n                # https://stackoverflow.com/questions/22390709/how-can-i-open-the-atom-editor-from-the-command-line-in-os-x\n                editor_cmd = default_editor_cmd\n        if editor_cmd:\n            os_cmd = f\"{editor_cmd} {file_source}\"\n            os.system(os_cmd)\n        return file_source\n\n    @classmethod\n    def open_tmp_text(cls, text: str, file_name: str = None) -&gt; str:\n        \"\"\"Open an editor for the given text in a newly created temporary file.\n\n        Args:\n            text(str): the text to write to a temporary file and then open\n            file_name(str): the name to use for the file\n\n        Returns:\n            str: the path to the temp file\n        \"\"\"\n        # see https://stackoverflow.com/a/8577226/1497139\n        # https://stackoverflow.com/a/3924253/1497139\n        with tempfile.NamedTemporaryFile(delete=False) as tmp:\n            with open(tmp.name, \"w\") as tmp_file:\n                tmp_file.write(text)\n                tmp_file.close()\n            if file_name is None:\n                file_path = tmp.name\n            else:\n                # https://stackoverflow.com/questions/3167154/how-to-split-a-dos-path-into-its-components-in-python\n                path = Path(tmp.name)\n                # https://stackoverflow.com/a/49798311/1497139\n                file_path = path.parent / file_name\n                os.rename(tmp.name, file_path)\n\n            return cls.open(str(file_path))\n</code></pre>"},{"location":"#osprojects.editor.Editor.extract_text","title":"<code>extract_text(html_text)</code>  <code>classmethod</code>","text":"<p>Extract the text from the given html_text.</p> <p>Parameters:</p> Name Type Description Default <code>html_text(str)</code> <p>the input for the html text</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the plain text</p> Source code in <code>osprojects/editor.py</code> <pre><code>@classmethod\ndef extract_text(cls, html_text: str) -&gt; str:\n    \"\"\"Extract the text from the given html_text.\n\n    Args:\n        html_text(str): the input for the html text\n\n    Returns:\n        str: the plain text\n    \"\"\"\n    soup = BeautifulSoup(html_text, features=\"html.parser\")\n\n    # kill all script and style elements\n    for script in soup([\"script\", \"style\"]):\n        script.extract()  # rip it out\n\n    # get text\n    text = soup.get_text()\n\n    # break into lines and remove leading and trailing space on each\n    lines = (line.strip() for line in text.splitlines())\n    # break multi-headlines into a line each\n    chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n    # drop blank lines\n    text = \"\\n\".join(chunk for chunk in chunks if chunk)\n    return text\n</code></pre>"},{"location":"#osprojects.editor.Editor.open","title":"<code>open(file_source, extract_text=True, default_editor_cmd='/usr/local/bin/atom')</code>  <code>classmethod</code>","text":"<p>Open an editor for the given file_source.</p> <p>Parameters:</p> Name Type Description Default <code>file_source(str)</code> <p>the path to the file</p> required <code>extract_text(bool)</code> <p>if True extract the text from html sources</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path to the file e.g. a temporary file if the file_source points to an url</p> Source code in <code>osprojects/editor.py</code> <pre><code>@classmethod\ndef open(\n    cls,\n    file_source: str,\n    extract_text: bool = True,\n    default_editor_cmd: str = \"/usr/local/bin/atom\",\n) -&gt; str:\n    \"\"\"Open an editor for the given file_source.\n\n    Args:\n        file_source(str): the path to the file\n        extract_text(bool): if True extract the text from html sources\n\n    Returns:\n        str: the path to the file e.g. a temporary file if the file_source points to an url\n    \"\"\"\n    # handle urls\n    # https://stackoverflow.com/a/45886824/1497139\n    if file_source.startswith(\"http\"):\n        url_source = urlopen(file_source)\n        # https://stackoverflow.com/a/19156107/1497139\n        charset = url_source.headers.get_content_charset()\n        # if charset fails here you might want to set it to utf-8 as a default!\n        text = url_source.read().decode(charset)\n        if extract_text:\n            # https://stackoverflow.com/a/24618186/1497139\n            text = cls.extract_text(text)\n\n        return cls.open_tmp_text(text)\n\n    editor_cmd = None\n    editor_env = os.getenv(\"EDITOR\")\n    if editor_env:\n        editor_cmd = editor_env\n    if platform.system() == \"Darwin\":\n        if not editor_env:\n            # https://stackoverflow.com/questions/22390709/how-can-i-open-the-atom-editor-from-the-command-line-in-os-x\n            editor_cmd = default_editor_cmd\n    if editor_cmd:\n        os_cmd = f\"{editor_cmd} {file_source}\"\n        os.system(os_cmd)\n    return file_source\n</code></pre>"},{"location":"#osprojects.editor.Editor.open_tmp_text","title":"<code>open_tmp_text(text, file_name=None)</code>  <code>classmethod</code>","text":"<p>Open an editor for the given text in a newly created temporary file.</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the text to write to a temporary file and then open</p> required <code>file_name(str)</code> <p>the name to use for the file</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path to the temp file</p> Source code in <code>osprojects/editor.py</code> <pre><code>@classmethod\ndef open_tmp_text(cls, text: str, file_name: str = None) -&gt; str:\n    \"\"\"Open an editor for the given text in a newly created temporary file.\n\n    Args:\n        text(str): the text to write to a temporary file and then open\n        file_name(str): the name to use for the file\n\n    Returns:\n        str: the path to the temp file\n    \"\"\"\n    # see https://stackoverflow.com/a/8577226/1497139\n    # https://stackoverflow.com/a/3924253/1497139\n    with tempfile.NamedTemporaryFile(delete=False) as tmp:\n        with open(tmp.name, \"w\") as tmp_file:\n            tmp_file.write(text)\n            tmp_file.close()\n        if file_name is None:\n            file_path = tmp.name\n        else:\n            # https://stackoverflow.com/questions/3167154/how-to-split-a-dos-path-into-its-components-in-python\n            path = Path(tmp.name)\n            # https://stackoverflow.com/a/49798311/1497139\n            file_path = path.parent / file_name\n            os.rename(tmp.name, file_path)\n\n        return cls.open(str(file_path))\n</code></pre>"},{"location":"#osprojects.github_api","title":"<code>github_api</code>","text":"<p>Created on 2024-08-27.</p> <p>@author: wf</p>"},{"location":"#osprojects.github_api.GitHubAction","title":"<code>GitHubAction</code>  <code>dataclass</code>","text":"<p>Represents a GitHub Action with its identifying information and log content.</p> <p>Attributes:</p> Name Type Description <code>repo</code> <code>GitHubRepo</code> <p>The repository associated with this action.</p> <code>run_id</code> <code>int</code> <p>The ID of the workflow run.</p> <code>job_id</code> <code>int</code> <p>The ID of the job within the run.</p> <code>log_content</code> <code>str</code> <p>The log content of the action.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>@dataclass\nclass GitHubAction:\n    \"\"\"Represents a GitHub Action with its identifying information and log\n    content.\n\n    Attributes:\n        repo (GitHubRepo): The repository associated with this action.\n        run_id (int): The ID of the workflow run.\n        job_id (int): The ID of the job within the run.\n        log_content (str): The log content of the action.\n    \"\"\"\n\n    repo: GitHubRepo\n    run_id: int\n    job_id: int\n    log_content: str = field(default=None, repr=False)\n    do_cache: bool = True\n\n    def __post_init__(self):\n        self.log_id = (\n            f\"{self.repo.owner}_{self.repo.project_id}_{self.run_id}_{self.job_id}\"\n        )\n        self.log_file = os.path.join(\n            self.repo.github.log_dir, f\"action_log_{self.log_id}.txt\"\n        )\n        # If log file exists, read the content\n        if os.path.exists(self.log_file):\n            with open(self.log_file, \"r\", encoding=\"utf-8\") as f:\n                self.log_content = f.read()\n\n    @classmethod\n    def from_url(cls, url: str) -&gt; \"GitHubAction\":\n        \"\"\"Create a GitHubAction instance from a GitHub Actions URL and fetch\n        its logs.\n\n        Args:\n            url (str): The GitHub Actions URL.\n\n        Returns:\n            GitHubAction: An instance of GitHubAction containing parsed information.\n\n        Raises:\n            ValueError: If the URL format is invalid or missing required components.\n        \"\"\"\n        parsed_url = urlparse(url)\n        path_parts = parsed_url.path.split(\"/\")\n\n        if len(path_parts) &lt; 8 or path_parts[3] != \"actions\" or path_parts[4] != \"runs\":\n            raise ValueError(\"Invalid GitHub Actions URL format\")\n\n        try:\n            repo = GitHubRepo(owner=path_parts[1], project_id=path_parts[2])\n            return cls(repo=repo, run_id=int(path_parts[5]), job_id=int(path_parts[7]))\n        except (IndexError, ValueError) as e:\n            raise ValueError(f\"Failed to parse GitHub Actions URL: {e}\")\n\n    @classmethod\n    def get_latest_workflow_run(cls, project):\n        \"\"\"Get the latest GitHub Actions workflow run for a given project.\n\n        Args:\n            project (OsProject): The project to check for the latest workflow run.\n\n        Returns:\n            dict: Information about the latest workflow run, or None if not found.\n        \"\"\"\n        url = f\"https://api.github.com/repos/{project.owner}/{project.project_id}/actions/runs\"\n        response = project.repo.github.get_response(\"fetch latest workflow run\", url)\n        runs = response.json().get(\"workflow_runs\", [])\n        run = None\n        if runs:\n            run = runs[0]  # Return the latest run\n        return run\n\n    def fetch_logs(self):\n        \"\"\"Fetch the logs for this GitHub Action.\"\"\"\n        if self.log_content is None:\n            api_url = f\"https://api.github.com/repos/{self.repo.owner}/{self.repo.project_id}/actions/jobs/{self.job_id}/logs\"\n            log_response = self.repo.github.get_response(\n                \"fetch job logs\", api_url, allow_redirects=True\n            )\n            self.log_content = log_response.content.decode(\"utf-8-sig\")\n            if self.do_cache:\n                self.save_logs()\n\n    def save_logs(self):\n        \"\"\"Save the log content to a local file.\"\"\"\n        if self.log_content is None:\n            raise ValueError(\"No log content to save. Make sure to fetch logs first.\")\n        with open(self.log_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(self.log_content)\n</code></pre>"},{"location":"#osprojects.github_api.GitHubAction.fetch_logs","title":"<code>fetch_logs()</code>","text":"<p>Fetch the logs for this GitHub Action.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def fetch_logs(self):\n    \"\"\"Fetch the logs for this GitHub Action.\"\"\"\n    if self.log_content is None:\n        api_url = f\"https://api.github.com/repos/{self.repo.owner}/{self.repo.project_id}/actions/jobs/{self.job_id}/logs\"\n        log_response = self.repo.github.get_response(\n            \"fetch job logs\", api_url, allow_redirects=True\n        )\n        self.log_content = log_response.content.decode(\"utf-8-sig\")\n        if self.do_cache:\n            self.save_logs()\n</code></pre>"},{"location":"#osprojects.github_api.GitHubAction.from_url","title":"<code>from_url(url)</code>  <code>classmethod</code>","text":"<p>Create a GitHubAction instance from a GitHub Actions URL and fetch its logs.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GitHub Actions URL.</p> required <p>Returns:</p> Name Type Description <code>GitHubAction</code> <code>GitHubAction</code> <p>An instance of GitHubAction containing parsed information.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL format is invalid or missing required components.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str) -&gt; \"GitHubAction\":\n    \"\"\"Create a GitHubAction instance from a GitHub Actions URL and fetch\n    its logs.\n\n    Args:\n        url (str): The GitHub Actions URL.\n\n    Returns:\n        GitHubAction: An instance of GitHubAction containing parsed information.\n\n    Raises:\n        ValueError: If the URL format is invalid or missing required components.\n    \"\"\"\n    parsed_url = urlparse(url)\n    path_parts = parsed_url.path.split(\"/\")\n\n    if len(path_parts) &lt; 8 or path_parts[3] != \"actions\" or path_parts[4] != \"runs\":\n        raise ValueError(\"Invalid GitHub Actions URL format\")\n\n    try:\n        repo = GitHubRepo(owner=path_parts[1], project_id=path_parts[2])\n        return cls(repo=repo, run_id=int(path_parts[5]), job_id=int(path_parts[7]))\n    except (IndexError, ValueError) as e:\n        raise ValueError(f\"Failed to parse GitHub Actions URL: {e}\")\n</code></pre>"},{"location":"#osprojects.github_api.GitHubAction.get_latest_workflow_run","title":"<code>get_latest_workflow_run(project)</code>  <code>classmethod</code>","text":"<p>Get the latest GitHub Actions workflow run for a given project.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>OsProject</code> <p>The project to check for the latest workflow run.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Information about the latest workflow run, or None if not found.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>@classmethod\ndef get_latest_workflow_run(cls, project):\n    \"\"\"Get the latest GitHub Actions workflow run for a given project.\n\n    Args:\n        project (OsProject): The project to check for the latest workflow run.\n\n    Returns:\n        dict: Information about the latest workflow run, or None if not found.\n    \"\"\"\n    url = f\"https://api.github.com/repos/{project.owner}/{project.project_id}/actions/runs\"\n    response = project.repo.github.get_response(\"fetch latest workflow run\", url)\n    runs = response.json().get(\"workflow_runs\", [])\n    run = None\n    if runs:\n        run = runs[0]  # Return the latest run\n    return run\n</code></pre>"},{"location":"#osprojects.github_api.GitHubAction.save_logs","title":"<code>save_logs()</code>","text":"<p>Save the log content to a local file.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def save_logs(self):\n    \"\"\"Save the log content to a local file.\"\"\"\n    if self.log_content is None:\n        raise ValueError(\"No log content to save. Make sure to fetch logs first.\")\n    with open(self.log_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(self.log_content)\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi","title":"<code>GitHubApi</code>","text":"<p>access to GitHubApi - needed for rate limit handling avoidance via access token</p> Source code in <code>osprojects/github_api.py</code> <pre><code>class GitHubApi:\n    \"\"\"\n    access to GitHubApi - needed for rate limit handling avoidance\n    via access token\n    \"\"\"\n\n    githubapi_instance: \"GitHubApi\" = None\n\n    @classmethod\n    def get_instance(cls) -&gt; \"GitHubApi\":\n        \"\"\"Singleton access.\"\"\"\n        if cls.githubapi_instance is None:\n            cls.githubapi_instance = cls()\n        return cls.githubapi_instance\n\n    def __init__(self):\n        \"\"\"constructor.\"\"\"\n        home_dir = os.path.expanduser(\"~\")\n        self.base_dir = os.path.join(home_dir, \".github\")\n        os.makedirs(self.base_dir, exist_ok=True)\n        self.cache_dir = os.path.join(self.base_dir, \"cache\")\n        os.makedirs(self.cache_dir, exist_ok=True)\n        self.log_dir = os.path.join(self.base_dir, \"log\")\n        os.makedirs(self.log_dir, exist_ok=True)\n        self.access_token = self.load_access_token()\n        self.headers = (\n            {\"Authorization\": f\"token {self.access_token}\"} if self.access_token else {}\n        )\n        self.api_url = \"https://api.github.com\"\n\n    def load_access_token(self) -&gt; str:\n        \"\"\"If $HOME/.github/access_token.json exists read the token from\n        there.\"\"\"\n        # Specify the path to the access token file\n        token_file_path = os.path.join(self.base_dir, \"access_token.json\")\n\n        # Check if the file exists and read the token\n        if os.path.exists(token_file_path):\n            with open(token_file_path, \"r\") as token_file:\n                token_data = json.load(token_file)\n                return token_data.get(\"access_token\")\n\n        # Return None if no token file is found\n        return None\n\n    def get_response(self, title: str, url: str, params={}, allow_redirects=True):\n        \"\"\"Get response from GitHub API or Google Docs API.\n\n        Args:\n            title (str): Description of the request\n            url (str): URL to send the request to\n            params (dict): Query parameters for the request\n            allow_redirects (bool): Whether to follow redirects\n\n        Returns:\n            requests.Response: The response object\n        \"\"\"\n        response = requests.get(\n            url, headers=self.headers, params=params, allow_redirects=allow_redirects\n        )\n\n        if response.status_code == 302 and not allow_redirects:\n            # Return the redirect URL if we're not following redirects\n            return response.headers[\"Location\"]\n\n        if response.status_code not in [200, 302]:\n            err_msg = (\n                f\"Failed to {title} for {url}: {response.status_code} - {response.text}\"\n            )\n            raise Exception(err_msg)\n\n        return response\n\n    def repos_for_owner(self, owner: str, cache_expiry: int = 300) -&gt; list[dict]:\n        \"\"\"Retrieve all repositories for the given owner, using cache if\n        available and valid, or via API otherwise.\n\n        This method first checks if the repository data is available in the cache. If not, it fetches the\n        data from the GitHub API and caches it for future use.\n\n        Args:\n            owner (str): The username of the owner whose repositories are being retrieved.\n            cache_expiry (int, optional): The cache expiry time in seconds. Defaults to 60 seconds (1 minute).\n\n        Returns:\n            list[dict]: A list of dictionaries representing repositories.\n        \"\"\"\n        # Attempt to retrieve from cache\n        cache_file, cache_content, cache_age = self.repos_for_owner_from_cache(owner)\n\n        # Use cache if it exists and is not expired\n        if cache_content is not None and (\n            cache_age is None or cache_age &lt; cache_expiry\n        ):\n            return cache_content\n\n        # If cache is not available or expired, retrieve from API\n        repos = self.repos_for_owner_via_api(owner)\n\n        # Cache the result\n        with open(cache_file, \"w\") as f:\n            json.dump(repos, f)\n\n        return repos\n\n    def repos_for_owner_from_cache(\n        self, owner: str\n    ) -&gt; tuple[str, list[dict] | None, float | None]:\n        \"\"\"Retrieve repositories for the given owner from the cache.\n\n        Args:\n            owner (str): The username of the owner whose repositories are being retrieved.\n\n        Returns:\n            tuple[str, list[dict] | None, float | None]: A tuple containing:\n                - cache_file (str): The path to the cache file.\n                - cache_content (list[dict] | None): A list of dictionaries representing repositories if cached data exists, None otherwise.\n                - cache_age (float | None): The age of the cache in seconds if cached data exists, None otherwise.\n        \"\"\"\n        cache_file = os.path.join(self.cache_dir, f\"{owner}_repos.json\")\n        cache_content = None\n        cache_age = None\n\n        # Check if cached data exists and is still valid\n        if os.path.exists(cache_file):\n            cache_age = time.time() - os.path.getmtime(cache_file)\n            with open(cache_file, \"r\") as f:\n                cache_content = json.load(f)\n\n        return cache_file, cache_content, cache_age\n\n    def repos_for_owner_via_api(self, owner: str) -&gt; list[dict]:\n        \"\"\"Retrieve all repositories for the given owner directly from the\n        GitHub API.\n\n        Args:\n            owner (str): The username of the owner whose repositories are being retrieved.\n\n        Returns:\n            list[dict]: A list of dictionaries representing repositories retrieved from the GitHub API.\n        \"\"\"\n        url = f\"{self.api_url}/users/{owner}/repos\"\n        params = {\n            \"type\": \"all\",\n            \"per_page\": 100,\n        }  # Include all repo types, 100 per page\n        all_repos = []\n        page = 1\n\n        while True:\n            params[\"page\"] = page\n            response = self.get_response(\"fetch repositories\", url, params)\n            repos = response.json()\n            if not repos:\n                break  # No more repositories to fetch\n\n            all_repos.extend(repos)\n            page += 1\n\n        repos = all_repos\n        return repos\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi.__init__","title":"<code>__init__()</code>","text":"<p>constructor.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def __init__(self):\n    \"\"\"constructor.\"\"\"\n    home_dir = os.path.expanduser(\"~\")\n    self.base_dir = os.path.join(home_dir, \".github\")\n    os.makedirs(self.base_dir, exist_ok=True)\n    self.cache_dir = os.path.join(self.base_dir, \"cache\")\n    os.makedirs(self.cache_dir, exist_ok=True)\n    self.log_dir = os.path.join(self.base_dir, \"log\")\n    os.makedirs(self.log_dir, exist_ok=True)\n    self.access_token = self.load_access_token()\n    self.headers = (\n        {\"Authorization\": f\"token {self.access_token}\"} if self.access_token else {}\n    )\n    self.api_url = \"https://api.github.com\"\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi.get_instance","title":"<code>get_instance()</code>  <code>classmethod</code>","text":"<p>Singleton access.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>@classmethod\ndef get_instance(cls) -&gt; \"GitHubApi\":\n    \"\"\"Singleton access.\"\"\"\n    if cls.githubapi_instance is None:\n        cls.githubapi_instance = cls()\n    return cls.githubapi_instance\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi.get_response","title":"<code>get_response(title, url, params={}, allow_redirects=True)</code>","text":"<p>Get response from GitHub API or Google Docs API.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Description of the request</p> required <code>url</code> <code>str</code> <p>URL to send the request to</p> required <code>params</code> <code>dict</code> <p>Query parameters for the request</p> <code>{}</code> <code>allow_redirects</code> <code>bool</code> <p>Whether to follow redirects</p> <code>True</code> <p>Returns:</p> Type Description <p>requests.Response: The response object</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def get_response(self, title: str, url: str, params={}, allow_redirects=True):\n    \"\"\"Get response from GitHub API or Google Docs API.\n\n    Args:\n        title (str): Description of the request\n        url (str): URL to send the request to\n        params (dict): Query parameters for the request\n        allow_redirects (bool): Whether to follow redirects\n\n    Returns:\n        requests.Response: The response object\n    \"\"\"\n    response = requests.get(\n        url, headers=self.headers, params=params, allow_redirects=allow_redirects\n    )\n\n    if response.status_code == 302 and not allow_redirects:\n        # Return the redirect URL if we're not following redirects\n        return response.headers[\"Location\"]\n\n    if response.status_code not in [200, 302]:\n        err_msg = (\n            f\"Failed to {title} for {url}: {response.status_code} - {response.text}\"\n        )\n        raise Exception(err_msg)\n\n    return response\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi.load_access_token","title":"<code>load_access_token()</code>","text":"<p>If $HOME/.github/access_token.json exists read the token from there.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def load_access_token(self) -&gt; str:\n    \"\"\"If $HOME/.github/access_token.json exists read the token from\n    there.\"\"\"\n    # Specify the path to the access token file\n    token_file_path = os.path.join(self.base_dir, \"access_token.json\")\n\n    # Check if the file exists and read the token\n    if os.path.exists(token_file_path):\n        with open(token_file_path, \"r\") as token_file:\n            token_data = json.load(token_file)\n            return token_data.get(\"access_token\")\n\n    # Return None if no token file is found\n    return None\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi.repos_for_owner","title":"<code>repos_for_owner(owner, cache_expiry=300)</code>","text":"<p>Retrieve all repositories for the given owner, using cache if available and valid, or via API otherwise.</p> <p>This method first checks if the repository data is available in the cache. If not, it fetches the data from the GitHub API and caches it for future use.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The username of the owner whose repositories are being retrieved.</p> required <code>cache_expiry</code> <code>int</code> <p>The cache expiry time in seconds. Defaults to 60 seconds (1 minute).</p> <code>300</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of dictionaries representing repositories.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def repos_for_owner(self, owner: str, cache_expiry: int = 300) -&gt; list[dict]:\n    \"\"\"Retrieve all repositories for the given owner, using cache if\n    available and valid, or via API otherwise.\n\n    This method first checks if the repository data is available in the cache. If not, it fetches the\n    data from the GitHub API and caches it for future use.\n\n    Args:\n        owner (str): The username of the owner whose repositories are being retrieved.\n        cache_expiry (int, optional): The cache expiry time in seconds. Defaults to 60 seconds (1 minute).\n\n    Returns:\n        list[dict]: A list of dictionaries representing repositories.\n    \"\"\"\n    # Attempt to retrieve from cache\n    cache_file, cache_content, cache_age = self.repos_for_owner_from_cache(owner)\n\n    # Use cache if it exists and is not expired\n    if cache_content is not None and (\n        cache_age is None or cache_age &lt; cache_expiry\n    ):\n        return cache_content\n\n    # If cache is not available or expired, retrieve from API\n    repos = self.repos_for_owner_via_api(owner)\n\n    # Cache the result\n    with open(cache_file, \"w\") as f:\n        json.dump(repos, f)\n\n    return repos\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi.repos_for_owner_from_cache","title":"<code>repos_for_owner_from_cache(owner)</code>","text":"<p>Retrieve repositories for the given owner from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The username of the owner whose repositories are being retrieved.</p> required <p>Returns:</p> Type Description <code>tuple[str, list[dict] | None, float | None]</code> <p>tuple[str, list[dict] | None, float | None]: A tuple containing: - cache_file (str): The path to the cache file. - cache_content (list[dict] | None): A list of dictionaries representing repositories if cached data exists, None otherwise. - cache_age (float | None): The age of the cache in seconds if cached data exists, None otherwise.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def repos_for_owner_from_cache(\n    self, owner: str\n) -&gt; tuple[str, list[dict] | None, float | None]:\n    \"\"\"Retrieve repositories for the given owner from the cache.\n\n    Args:\n        owner (str): The username of the owner whose repositories are being retrieved.\n\n    Returns:\n        tuple[str, list[dict] | None, float | None]: A tuple containing:\n            - cache_file (str): The path to the cache file.\n            - cache_content (list[dict] | None): A list of dictionaries representing repositories if cached data exists, None otherwise.\n            - cache_age (float | None): The age of the cache in seconds if cached data exists, None otherwise.\n    \"\"\"\n    cache_file = os.path.join(self.cache_dir, f\"{owner}_repos.json\")\n    cache_content = None\n    cache_age = None\n\n    # Check if cached data exists and is still valid\n    if os.path.exists(cache_file):\n        cache_age = time.time() - os.path.getmtime(cache_file)\n        with open(cache_file, \"r\") as f:\n            cache_content = json.load(f)\n\n    return cache_file, cache_content, cache_age\n</code></pre>"},{"location":"#osprojects.github_api.GitHubApi.repos_for_owner_via_api","title":"<code>repos_for_owner_via_api(owner)</code>","text":"<p>Retrieve all repositories for the given owner directly from the GitHub API.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The username of the owner whose repositories are being retrieved.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of dictionaries representing repositories retrieved from the GitHub API.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>def repos_for_owner_via_api(self, owner: str) -&gt; list[dict]:\n    \"\"\"Retrieve all repositories for the given owner directly from the\n    GitHub API.\n\n    Args:\n        owner (str): The username of the owner whose repositories are being retrieved.\n\n    Returns:\n        list[dict]: A list of dictionaries representing repositories retrieved from the GitHub API.\n    \"\"\"\n    url = f\"{self.api_url}/users/{owner}/repos\"\n    params = {\n        \"type\": \"all\",\n        \"per_page\": 100,\n    }  # Include all repo types, 100 per page\n    all_repos = []\n    page = 1\n\n    while True:\n        params[\"page\"] = page\n        response = self.get_response(\"fetch repositories\", url, params)\n        repos = response.json()\n        if not repos:\n            break  # No more repositories to fetch\n\n        all_repos.extend(repos)\n        page += 1\n\n    repos = all_repos\n    return repos\n</code></pre>"},{"location":"#osprojects.github_api.GitHubRepo","title":"<code>GitHubRepo</code>  <code>dataclass</code>","text":"<p>Represents a GitHub Repository.</p> <p>Attributes:</p> Name Type Description <code>owner</code> <code>str</code> <p>The owner of the repository.</p> <code>project_id</code> <code>str</code> <p>The name/id of the repository.</p> Source code in <code>osprojects/github_api.py</code> <pre><code>@dataclass\nclass GitHubRepo:\n    \"\"\"Represents a GitHub Repository.\n\n    Attributes:\n        owner (str): The owner of the repository.\n        project_id (str): The name/id of the repository.\n    \"\"\"\n\n    owner: str\n    project_id: str\n\n    def __post_init__(self):\n        self.github = GitHubApi.get_instance()\n\n    @classmethod\n    def from_url(cls, url: str) -&gt; (str, str):\n        \"\"\"Resolve project url to owner and project name.\n\n        Returns:\n            (owner, project)\n        \"\"\"\n        # https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n        pattern = r\"((https?:\\/\\/github\\.com\\/)|(git@github\\.com:))(?P&lt;owner&gt;[^/?#]+)\\/(?P&lt;project_id&gt;[^\\./?#]+)(\\.git)?\"\n        match = re.match(pattern=pattern, string=url)\n        repo = None\n        if match:\n            owner = match.group(\"owner\")\n            project_id = match.group(\"project_id\")\n            if owner and project_id:\n                repo = cls(owner=owner, project_id=project_id)\n            else:\n                pass\n        else:\n            pass\n        return repo\n\n    def ticketUrl(self):\n        return f\"{self.github.api_url}/repos/{self.owner}/{self.project_id}/issues\"\n\n    def projectUrl(self):\n        return f\"https://github.com/{self.owner}/{self.project_id}\"\n\n    def getIssueRecords(self, limit: int = None, **params) -&gt; List[Dict]:\n        all_issues_records = []\n        nextResults = True\n        params[\"per_page\"] = 100\n        params[\"page\"] = 1\n        fetched_count = 0  # Counter to track the number of issues fetched\n        while nextResults:\n            response = self.github.get_response(\n                \"fetch tickets\", self.ticketUrl(), params\n            )\n            issue_records = json.loads(response.text)\n            all_issues_records.extend(issue_records)\n            fetched_count += 1\n            # Check if we have reached the limit\n            if limit is not None and fetched_count &gt;= limit:\n                nextResults = False\n                break\n\n            if len(issue_records) &lt; 100:\n                nextResults = False\n            else:\n                params[\"page\"] += 1\n        return all_issues_records\n</code></pre>"},{"location":"#osprojects.github_api.GitHubRepo.from_url","title":"<code>from_url(url)</code>  <code>classmethod</code>","text":"<p>Resolve project url to owner and project name.</p> <p>Returns:</p> Type Description <code>(str, str)</code> <p>(owner, project)</p> Source code in <code>osprojects/github_api.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str) -&gt; (str, str):\n    \"\"\"Resolve project url to owner and project name.\n\n    Returns:\n        (owner, project)\n    \"\"\"\n    # https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n    pattern = r\"((https?:\\/\\/github\\.com\\/)|(git@github\\.com:))(?P&lt;owner&gt;[^/?#]+)\\/(?P&lt;project_id&gt;[^\\./?#]+)(\\.git)?\"\n    match = re.match(pattern=pattern, string=url)\n    repo = None\n    if match:\n        owner = match.group(\"owner\")\n        project_id = match.group(\"project_id\")\n        if owner and project_id:\n            repo = cls(owner=owner, project_id=project_id)\n        else:\n            pass\n    else:\n        pass\n    return repo\n</code></pre>"},{"location":"#osprojects.osproject","title":"<code>osproject</code>","text":"<p>Created on 2022-01-24.</p> <p>@author: wf</p>"},{"location":"#osprojects.osproject.Commit","title":"<code>Commit</code>","text":"<p>               Bases: <code>object</code></p> <p>A commit.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class Commit(object):\n    \"\"\"A commit.\"\"\"\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"host\": \"https://github.com/WolfgangFahl/pyOpenSourceProjects\",\n                \"path\": \"\",\n                \"project\": \"pyOpenSourceProjects\",\n                \"subject\": \"Initial commit\",\n                \"name\": \"GitHub\",  # TicketSystem\n                \"date\": datetime.datetime.fromisoformat(\"2022-01-24 07:02:55+01:00\"),\n                \"hash\": \"106254f\",\n            }\n        ]\n        return samples\n\n    def toWikiMarkup(self):\n        \"\"\"Returns Commit as wiki markup.\"\"\"\n        params = [\n            f\"{attr}={getattr(self, attr, '')}\" for attr in self.getSamples()[0].keys()\n        ]\n        markup = f\"{{{{commit|{'|'.join(params)}|storemode=subobject|viewmode=line}}}}\"\n        return markup\n</code></pre>"},{"location":"#osprojects.osproject.Commit.toWikiMarkup","title":"<code>toWikiMarkup()</code>","text":"<p>Returns Commit as wiki markup.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def toWikiMarkup(self):\n    \"\"\"Returns Commit as wiki markup.\"\"\"\n    params = [\n        f\"{attr}={getattr(self, attr, '')}\" for attr in self.getSamples()[0].keys()\n    ]\n    markup = f\"{{{{commit|{'|'.join(params)}|storemode=subobject|viewmode=line}}}}\"\n    return markup\n</code></pre>"},{"location":"#osprojects.osproject.OsProject","title":"<code>OsProject</code>","text":"<p>A GitHub based opens source project.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class OsProject:\n    \"\"\"A GitHub based opens source project.\"\"\"\n\n    def __init__(self, owner: str = None, project_id: str = None):\n        self.repo_info = None  # might be fetched\n        self.folder = None  # set for local projects\n        if owner and project_id:\n            self.repo = GitHubRepo(owner=owner, project_id=project_id)\n\n    @classmethod\n    def fromUrl(cls, url: str) -&gt; \"OsProject\":\n        \"\"\"Init OsProject from given url.\"\"\"\n        if \"github.com\" in url:\n            os_project = cls()\n            os_project.repo = GitHubRepo.from_url(url)\n        else:\n            raise Exception(f\"url '{url}' is not a github.com url \")\n        return os_project\n\n    @classmethod\n    def fromRepo(cls):\n        \"\"\"Init OsProject from repo in current working directory.\"\"\"\n        url = subprocess.check_output([\"git\", \"config\", \"--get\", \"remote.origin.url\"])\n        url = url.decode().strip(\"\\n\")\n        repo = cls.fromUrl(url)\n        return repo\n\n    def getIssues(self, limit: int = None, **params) -&gt; List[Ticket]:\n\n        # Fetch the raw issue records using the new getIssueRecords method\n        issue_records = self.repo.getIssueRecords(limit=limit, **params)\n\n        issues = []\n        for record in issue_records:\n            tr = {\n                \"project\": self.repo.project_id,\n                \"title\": record.get(\"title\"),\n                \"body\": record.get(\"body\", \"\"),\n                \"createdAt\": (\n                    parse(record.get(\"created_at\")) if record.get(\"created_at\") else \"\"\n                ),\n                \"closedAt\": (\n                    parse(record.get(\"closed_at\")) if record.get(\"closed_at\") else \"\"\n                ),\n                \"state\": record.get(\"state\"),\n                \"number\": record.get(\"number\"),\n                \"url\": f\"{self.projectUrl()}/issues/{record.get('number')}\",\n            }\n            issues.append(Ticket.init_from_dict(**tr))\n\n            # Check if we have reached the limit\n            if limit is not None and len(issues) &gt;= limit:\n                break\n\n        return issues\n\n    def getAllTickets(\n        self, limit: int = None, with_sort: bool = True\n    ) -&gt; Dict[int, Ticket]:\n        \"\"\"\n        Get all Tickets of the project - closed and open ones\n\n        Args:\n            limit(int): if set, limit the number of tickets retrieved\n            with_sort(bool): if True, sort the tickets by number in descending order\n\n        Returns:\n            Dict[int, Ticket]: A dictionary of tickets keyed by their number\n        \"\"\"\n        tickets = self.getIssues(state=\"all\", limit=limit)\n\n        # Sort the tickets if with_sort is True\n        if with_sort:\n            tickets.sort(key=lambda r: getattr(r, \"number\"), reverse=True)\n\n        # Convert the list of tickets into a dictionary keyed by the ticket number\n        tickets_dict = {ticket.number: ticket for ticket in tickets}\n\n        return tickets_dict\n\n    def getComments(self, issue_number: int) -&gt; List[dict]:\n        \"\"\"Fetch all comments for a specific issue number from GitHub.\"\"\"\n        comments_url = self.commentUrl(issue_number)\n        response = self.get_response(\"fetch comments\", comments_url)\n        return response.json()\n\n    def projectUrl(self):\n        return self.repo.projectUrl()\n\n    def commitUrl(self, commit_id: str):\n        return f\"{self.projectUrl()}/commit/{commit_id}\"\n\n    def commentUrl(self, issue_number: int):\n        \"\"\"Construct the URL for accessing comments of a specific issue.\"\"\"\n        return f\"{self.repo.github.api_url}/repos/{self.repo.owner}/{self.repo.project_id}/issues/{issue_number}/comments\"\n\n    @property\n    def project_id(self):\n        return self.repo.project_id\n\n    @property\n    def owner(self):\n        return self.repo.owner\n\n    @property\n    def title(self):\n        return self.repo_info.get(\"name\") or self.project_id\n\n    @property\n    def url(self):\n        return (\n            self.repo_info.get(\"html_url\")\n            or f\"https://github.com/{self.repo.owner}/{self.project_id}\"\n        )\n\n    @property\n    def description(self):\n        return self.repo_info.get(\"description\") or \"\"\n\n    @property\n    def language(self):\n        return self.repo_info.get(\"language\") or \"python\"\n\n    @property\n    def created_at(self):\n        created_at = self.repo_info.get(\"created_at\")\n        return (\n            datetime.datetime.fromisoformat(created_at.rstrip(\"Z\"))\n            if created_at\n            else None\n        )\n\n    @property\n    def updated_at(self):\n        updated_at = self.repo_info.get(\"updated_at\")\n        return (\n            datetime.datetime.fromisoformat(updated_at.rstrip(\"Z\"))\n            if updated_at\n            else None\n        )\n\n    @property\n    def stars(self):\n        return self.repo_info.get(\"stargazers_count\")\n\n    @property\n    def forks(self):\n        return self.repo_info.get(\"forks_count\")\n\n    @property\n    def fqid(self):\n        return f\"{self.repo.owner}/{self.repo.project_id}\"\n\n    def __str__(self):\n        return self.fqid\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"project_id\": \"pyOpenSourceProjects\",\n                \"owner\": \"WolfgangFahl\",\n                \"title\": \"pyOpenSourceProjects\",\n                \"url\": \"https://github.com/WolfgangFahl/pyOpenSourceProjects\",\n                \"description\": \"Helper Library to organize open source Projects\",\n                \"language\": \"Python\",\n                \"created_at\": datetime.datetime(year=2022, month=1, day=24),\n                \"updated_at\": datetime.datetime(year=2022, month=1, day=24),\n                \"stars\": 5,\n                \"forks\": 2,\n            }\n        ]\n        return samples\n\n    def getCommits(self) -&gt; List[Commit]:\n        commits = []\n        gitlogCmd = [\n            \"git\",\n            \"--no-pager\",\n            \"log\",\n            \"--reverse\",\n            r'--pretty=format:{\"name\":\"%cn\",\"date\":\"%cI\",\"hash\":\"%h\"}',\n        ]\n        gitLogCommitSubject = [\"git\", \"log\", \"--format=%s\", \"-n\", \"1\"]\n        rawCommitLogs = subprocess.check_output(gitlogCmd).decode()\n        for rawLog in rawCommitLogs.split(\"\\n\"):\n            log = json.loads(rawLog)\n            if log.get(\"date\", None) is not None:\n                log[\"date\"] = datetime.datetime.fromisoformat(log[\"date\"])\n            log[\"project\"] = self.project_id\n            log[\"host\"] = self.projectUrl()\n            log[\"path\"] = \"\"\n            log[\"subject\"] = subprocess.check_output(\n                [*gitLogCommitSubject, log[\"hash\"]]\n            )[\n                :-1\n            ].decode()  # seperate query to avoid json escaping issues\n            commit = Commit()\n            for k, v in log.items():\n                setattr(commit, k, v)\n            commits.append(commit)\n        return commits\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.commentUrl","title":"<code>commentUrl(issue_number)</code>","text":"<p>Construct the URL for accessing comments of a specific issue.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def commentUrl(self, issue_number: int):\n    \"\"\"Construct the URL for accessing comments of a specific issue.\"\"\"\n    return f\"{self.repo.github.api_url}/repos/{self.repo.owner}/{self.repo.project_id}/issues/{issue_number}/comments\"\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.fromRepo","title":"<code>fromRepo()</code>  <code>classmethod</code>","text":"<p>Init OsProject from repo in current working directory.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef fromRepo(cls):\n    \"\"\"Init OsProject from repo in current working directory.\"\"\"\n    url = subprocess.check_output([\"git\", \"config\", \"--get\", \"remote.origin.url\"])\n    url = url.decode().strip(\"\\n\")\n    repo = cls.fromUrl(url)\n    return repo\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.fromUrl","title":"<code>fromUrl(url)</code>  <code>classmethod</code>","text":"<p>Init OsProject from given url.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef fromUrl(cls, url: str) -&gt; \"OsProject\":\n    \"\"\"Init OsProject from given url.\"\"\"\n    if \"github.com\" in url:\n        os_project = cls()\n        os_project.repo = GitHubRepo.from_url(url)\n    else:\n        raise Exception(f\"url '{url}' is not a github.com url \")\n    return os_project\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.getAllTickets","title":"<code>getAllTickets(limit=None, with_sort=True)</code>","text":"<p>Get all Tickets of the project - closed and open ones</p> <p>Parameters:</p> Name Type Description Default <code>limit(int)</code> <p>if set, limit the number of tickets retrieved</p> required <code>with_sort(bool)</code> <p>if True, sort the tickets by number in descending order</p> required <p>Returns:</p> Type Description <code>Dict[int, Ticket]</code> <p>Dict[int, Ticket]: A dictionary of tickets keyed by their number</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def getAllTickets(\n    self, limit: int = None, with_sort: bool = True\n) -&gt; Dict[int, Ticket]:\n    \"\"\"\n    Get all Tickets of the project - closed and open ones\n\n    Args:\n        limit(int): if set, limit the number of tickets retrieved\n        with_sort(bool): if True, sort the tickets by number in descending order\n\n    Returns:\n        Dict[int, Ticket]: A dictionary of tickets keyed by their number\n    \"\"\"\n    tickets = self.getIssues(state=\"all\", limit=limit)\n\n    # Sort the tickets if with_sort is True\n    if with_sort:\n        tickets.sort(key=lambda r: getattr(r, \"number\"), reverse=True)\n\n    # Convert the list of tickets into a dictionary keyed by the ticket number\n    tickets_dict = {ticket.number: ticket for ticket in tickets}\n\n    return tickets_dict\n</code></pre>"},{"location":"#osprojects.osproject.OsProject.getComments","title":"<code>getComments(issue_number)</code>","text":"<p>Fetch all comments for a specific issue number from GitHub.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def getComments(self, issue_number: int) -&gt; List[dict]:\n    \"\"\"Fetch all comments for a specific issue number from GitHub.\"\"\"\n    comments_url = self.commentUrl(issue_number)\n    response = self.get_response(\"fetch comments\", comments_url)\n    return response.json()\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects","title":"<code>OsProjects</code>","text":"<p>A set of open source projects.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class OsProjects:\n    \"\"\"A set of open source projects.\"\"\"\n\n    def __init__(self):\n        \"\"\"constructor.\"\"\"\n        self.projects = {}\n        self.projects_by_url = {}\n        self.local_projects = {}\n        self.selected_projects = {}\n        self.owners = []\n        self.github = GitHubApi.get_instance()\n\n    def clear_selection(self):\n        self.selected_projects = {}\n\n    def add_selection(self, project):\n        is_fork = project.repo_info[\"fork\"]\n        if not is_fork:\n            self.selected_projects[project.projectUrl()] = project\n\n    def select_projects(self, owners=None, project_id=None, local_only=False):\n        \"\"\"Select projects based on given criteria.\n\n        Args:\n            owners (Optional[list[str]]): The owners of the projects to select.\n            project_id (Optional[str]): The ID of a specific project to select.\n            local_only (bool): Whether to select only local projects.\n\n        Returns:\n            Dict[str, OsProject]: A dictionary of selected projects.\n\n        Raises:\n            ValueError: If owner or local_only flag is not specified with project_id.\n        \"\"\"\n        if project_id:\n            if owners:\n                for owner in owners:\n                    key = f\"https://github.com/{owner}/{project_id}\"\n                    project = self.projects_by_url.get(key)\n                    if project:\n                        self.add_selection(project)\n            elif local_only:\n                for _url, project in self.local_projects.items():\n                    if project.project_id == project_id:\n                        self.add_selection(project)\n            else:\n                raise ValueError(\n                    \"Owner or local_only flag must be specified with project_id\"\n                )\n\n        elif owners:\n            for owner in owners:\n                if owner in self.projects:\n                    for project in self.projects[owner].values():\n                        self.add_selection(project)\n        elif local_only:\n            for project in self.local_projects.values():\n                self.add_selection(project)\n        else:\n            for project in self.projects_by_url.values():\n                self.add_selection(project)\n\n        return self.selected_projects\n\n    def filter_projects(self, language=None, local_only=False):\n        \"\"\"Filter the selected projects based on language and locality.\n\n        Args:\n            language (str, optional): The programming language to filter by.\n            local_only (bool, optional): If True, only return local projects.\n\n        Returns:\n            Dict[str, OsProject]: The filtered projects.\n        \"\"\"\n        filtered_projects = {}\n\n        for url, project in self.selected_projects.items():\n            include_project = True\n\n            if language and project.language != language:\n                include_project = False\n\n            if local_only and not project.folder:\n                include_project = False\n\n            if include_project:\n                filtered_projects[url] = project\n\n        self.selected_projects = filtered_projects\n        return self.selected_projects\n\n    def add_projects_of_owner(self, owner: str, cache_expiry: int = 300):\n        \"\"\"Add the projects of the given owner.\"\"\"\n        if not owner in self.projects:\n            self.projects[owner] = {}\n            repo_infos = self.github.repos_for_owner(owner, cache_expiry)\n            for repo_info in repo_infos:\n                project_id = repo_info[\"name\"]\n                os_project = OsProject(owner=owner, project_id=project_id)\n                os_project.repo_info = repo_info\n                self.projects[owner][project_id] = os_project\n                self.projects_by_url[os_project.projectUrl()] = os_project\n        else:\n            # owner already known\n            pass\n\n    @classmethod\n    def from_owners(cls, owners: list[str]):\n        osp = cls()\n        for owner in owners:\n            osp.add_projects_of_owner(owner)\n        return osp\n\n    @classmethod\n    def get_project_url_from_git_config(cls, project_path: str) -&gt; Optional[str]:\n        \"\"\"Get the project URL from the git config file.\n\n        Args:\n            project_path (str): The path to the project directory.\n\n        Returns:\n            Optional[str]: The project URL if found, None otherwise.\n        \"\"\"\n        config_path = os.path.join(project_path, \".git\", \"config\")\n        if not os.path.exists(config_path):\n            return None\n\n        config = configparser.ConfigParser()\n        config.read(config_path)\n\n        if 'remote \"origin\"' not in config:\n            return None\n\n        url = config['remote \"origin\"'][\"url\"]\n        # remove trailing / if any\n        url = url.rstrip(\"/\")\n        return url\n\n    @classmethod\n    def from_folder(cls, folder_path: str, with_progress: bool = False) -&gt; \"OsProjects\":\n        \"\"\"Collect all github projects from the given folders.\n\n        Args:\n            folder_path (str): The path to the folder containing projects.\n            with_progress (bool): Whether to display a progress bar. Defaults to True.\n\n        Returns:\n            OsProjects: An instance of OsProjects with collected projects.\n        \"\"\"\n        osp = cls()\n        owners, repos_by_folder = cls.github_repos_of_folder(folder_path)\n\n        def process_owners(owners_iterable: Iterable[str]):\n            for owner in owners_iterable:\n                osp.add_projects_of_owner(owner)\n\n        if with_progress:\n            process_owners(tqdm(owners, desc=\"Processing owners\"))\n        else:\n            process_owners(owners)\n\n        for folder, repo in repos_by_folder.items():\n            project_url = repo.projectUrl()\n            if project_url not in osp.projects_by_url:\n                logging.warning(f\"{project_url} not found in projects_by_url\")\n            else:\n                local_project = osp.projects_by_url[project_url]\n                local_project.folder = folder\n                osp.local_projects[project_url] = local_project\n\n        return osp\n\n    @classmethod\n    def github_repos_of_folder(\n        cls, folder_path: str\n    ) -&gt; Tuple[Set[str], Dict[str, GitHubRepo]]:\n        \"\"\"Collect GitHub repositories from a given folder.\n\n        Args:\n            folder_path (str): The path to the folder to search for repositories.\n\n        Returns:\n            Tuple[Set[str], Dict[str, GitHubRepo]]: A tuple containing a set of owners\n            and a dictionary of repositories keyed by folder path.\n        \"\"\"\n        all_folders = []\n        repos_by_folder: Dict[str, GitHubRepo] = {}\n        owners: Set[str] = set()\n\n        for d in os.listdir(folder_path):\n            sub_folder = os.path.join(folder_path, d)\n            if os.path.isdir(sub_folder):\n                all_folders.append(sub_folder)\n\n        for folder in all_folders:\n            project_url = cls.get_project_url_from_git_config(folder)\n            if project_url:\n                github_repo = GitHubRepo.from_url(project_url)\n                if github_repo:\n                    repos_by_folder[folder] = github_repo\n                    owners.add(github_repo.owner)\n\n        return owners, repos_by_folder\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects.__init__","title":"<code>__init__()</code>","text":"<p>constructor.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def __init__(self):\n    \"\"\"constructor.\"\"\"\n    self.projects = {}\n    self.projects_by_url = {}\n    self.local_projects = {}\n    self.selected_projects = {}\n    self.owners = []\n    self.github = GitHubApi.get_instance()\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects.add_projects_of_owner","title":"<code>add_projects_of_owner(owner, cache_expiry=300)</code>","text":"<p>Add the projects of the given owner.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def add_projects_of_owner(self, owner: str, cache_expiry: int = 300):\n    \"\"\"Add the projects of the given owner.\"\"\"\n    if not owner in self.projects:\n        self.projects[owner] = {}\n        repo_infos = self.github.repos_for_owner(owner, cache_expiry)\n        for repo_info in repo_infos:\n            project_id = repo_info[\"name\"]\n            os_project = OsProject(owner=owner, project_id=project_id)\n            os_project.repo_info = repo_info\n            self.projects[owner][project_id] = os_project\n            self.projects_by_url[os_project.projectUrl()] = os_project\n    else:\n        # owner already known\n        pass\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects.filter_projects","title":"<code>filter_projects(language=None, local_only=False)</code>","text":"<p>Filter the selected projects based on language and locality.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>The programming language to filter by.</p> <code>None</code> <code>local_only</code> <code>bool</code> <p>If True, only return local projects.</p> <code>False</code> <p>Returns:</p> Type Description <p>Dict[str, OsProject]: The filtered projects.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def filter_projects(self, language=None, local_only=False):\n    \"\"\"Filter the selected projects based on language and locality.\n\n    Args:\n        language (str, optional): The programming language to filter by.\n        local_only (bool, optional): If True, only return local projects.\n\n    Returns:\n        Dict[str, OsProject]: The filtered projects.\n    \"\"\"\n    filtered_projects = {}\n\n    for url, project in self.selected_projects.items():\n        include_project = True\n\n        if language and project.language != language:\n            include_project = False\n\n        if local_only and not project.folder:\n            include_project = False\n\n        if include_project:\n            filtered_projects[url] = project\n\n    self.selected_projects = filtered_projects\n    return self.selected_projects\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects.from_folder","title":"<code>from_folder(folder_path, with_progress=False)</code>  <code>classmethod</code>","text":"<p>Collect all github projects from the given folders.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>The path to the folder containing projects.</p> required <code>with_progress</code> <code>bool</code> <p>Whether to display a progress bar. Defaults to True.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>OsProjects</code> <code>OsProjects</code> <p>An instance of OsProjects with collected projects.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef from_folder(cls, folder_path: str, with_progress: bool = False) -&gt; \"OsProjects\":\n    \"\"\"Collect all github projects from the given folders.\n\n    Args:\n        folder_path (str): The path to the folder containing projects.\n        with_progress (bool): Whether to display a progress bar. Defaults to True.\n\n    Returns:\n        OsProjects: An instance of OsProjects with collected projects.\n    \"\"\"\n    osp = cls()\n    owners, repos_by_folder = cls.github_repos_of_folder(folder_path)\n\n    def process_owners(owners_iterable: Iterable[str]):\n        for owner in owners_iterable:\n            osp.add_projects_of_owner(owner)\n\n    if with_progress:\n        process_owners(tqdm(owners, desc=\"Processing owners\"))\n    else:\n        process_owners(owners)\n\n    for folder, repo in repos_by_folder.items():\n        project_url = repo.projectUrl()\n        if project_url not in osp.projects_by_url:\n            logging.warning(f\"{project_url} not found in projects_by_url\")\n        else:\n            local_project = osp.projects_by_url[project_url]\n            local_project.folder = folder\n            osp.local_projects[project_url] = local_project\n\n    return osp\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects.get_project_url_from_git_config","title":"<code>get_project_url_from_git_config(project_path)</code>  <code>classmethod</code>","text":"<p>Get the project URL from the git config file.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str</code> <p>The path to the project directory.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The project URL if found, None otherwise.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef get_project_url_from_git_config(cls, project_path: str) -&gt; Optional[str]:\n    \"\"\"Get the project URL from the git config file.\n\n    Args:\n        project_path (str): The path to the project directory.\n\n    Returns:\n        Optional[str]: The project URL if found, None otherwise.\n    \"\"\"\n    config_path = os.path.join(project_path, \".git\", \"config\")\n    if not os.path.exists(config_path):\n        return None\n\n    config = configparser.ConfigParser()\n    config.read(config_path)\n\n    if 'remote \"origin\"' not in config:\n        return None\n\n    url = config['remote \"origin\"'][\"url\"]\n    # remove trailing / if any\n    url = url.rstrip(\"/\")\n    return url\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects.github_repos_of_folder","title":"<code>github_repos_of_folder(folder_path)</code>  <code>classmethod</code>","text":"<p>Collect GitHub repositories from a given folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>The path to the folder to search for repositories.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Tuple[Set[str], Dict[str, GitHubRepo]]: A tuple containing a set of owners</p> <code>Dict[str, GitHubRepo]</code> <p>and a dictionary of repositories keyed by folder path.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef github_repos_of_folder(\n    cls, folder_path: str\n) -&gt; Tuple[Set[str], Dict[str, GitHubRepo]]:\n    \"\"\"Collect GitHub repositories from a given folder.\n\n    Args:\n        folder_path (str): The path to the folder to search for repositories.\n\n    Returns:\n        Tuple[Set[str], Dict[str, GitHubRepo]]: A tuple containing a set of owners\n        and a dictionary of repositories keyed by folder path.\n    \"\"\"\n    all_folders = []\n    repos_by_folder: Dict[str, GitHubRepo] = {}\n    owners: Set[str] = set()\n\n    for d in os.listdir(folder_path):\n        sub_folder = os.path.join(folder_path, d)\n        if os.path.isdir(sub_folder):\n            all_folders.append(sub_folder)\n\n    for folder in all_folders:\n        project_url = cls.get_project_url_from_git_config(folder)\n        if project_url:\n            github_repo = GitHubRepo.from_url(project_url)\n            if github_repo:\n                repos_by_folder[folder] = github_repo\n                owners.add(github_repo.owner)\n\n    return owners, repos_by_folder\n</code></pre>"},{"location":"#osprojects.osproject.OsProjects.select_projects","title":"<code>select_projects(owners=None, project_id=None, local_only=False)</code>","text":"<p>Select projects based on given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>owners</code> <code>Optional[list[str]]</code> <p>The owners of the projects to select.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The ID of a specific project to select.</p> <code>None</code> <code>local_only</code> <code>bool</code> <p>Whether to select only local projects.</p> <code>False</code> <p>Returns:</p> Type Description <p>Dict[str, OsProject]: A dictionary of selected projects.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If owner or local_only flag is not specified with project_id.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def select_projects(self, owners=None, project_id=None, local_only=False):\n    \"\"\"Select projects based on given criteria.\n\n    Args:\n        owners (Optional[list[str]]): The owners of the projects to select.\n        project_id (Optional[str]): The ID of a specific project to select.\n        local_only (bool): Whether to select only local projects.\n\n    Returns:\n        Dict[str, OsProject]: A dictionary of selected projects.\n\n    Raises:\n        ValueError: If owner or local_only flag is not specified with project_id.\n    \"\"\"\n    if project_id:\n        if owners:\n            for owner in owners:\n                key = f\"https://github.com/{owner}/{project_id}\"\n                project = self.projects_by_url.get(key)\n                if project:\n                    self.add_selection(project)\n        elif local_only:\n            for _url, project in self.local_projects.items():\n                if project.project_id == project_id:\n                    self.add_selection(project)\n        else:\n            raise ValueError(\n                \"Owner or local_only flag must be specified with project_id\"\n            )\n\n    elif owners:\n        for owner in owners:\n            if owner in self.projects:\n                for project in self.projects[owner].values():\n                    self.add_selection(project)\n    elif local_only:\n        for project in self.local_projects.values():\n            self.add_selection(project)\n    else:\n        for project in self.projects_by_url.values():\n            self.add_selection(project)\n\n    return self.selected_projects\n</code></pre>"},{"location":"#osprojects.osproject.Ticket","title":"<code>Ticket</code>","text":"<p>               Bases: <code>object</code></p> <p>A Ticket.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>class Ticket(object):\n    \"\"\"A Ticket.\"\"\"\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"number\": 2,\n                \"title\": \"Get Tickets in Wiki notation from github API\",\n                \"createdAt\": datetime.datetime.fromisoformat(\n                    \"2022-01-24 07:41:29+00:00\"\n                ),\n                \"closedAt\": datetime.datetime.fromisoformat(\n                    \"2022-01-25 07:43:04+00:00\"\n                ),\n                \"url\": \"https://github.com/WolfgangFahl/pyOpenSourceProjects/issues/2\",\n                \"project\": \"pyOpenSourceProjects\",\n                \"state\": \"closed\",\n            }\n        ]\n        return samples\n\n    @classmethod\n    def init_from_dict(cls, **records):\n        \"\"\"Inits Ticket from given args.\"\"\"\n        issue = Ticket()\n        for k, v in records.items():\n            setattr(issue, k, v)\n        return issue\n\n    def toWikiMarkup(self) -&gt; str:\n        \"\"\"Returns Ticket in wiki markup.\"\"\"\n        return f\"\"\"# {{{{Ticket\n|number={self.number}\n|title={self.title}\n|project={self.project}\n|createdAt={self.createdAt if self.createdAt else \"\"}\n|closedAt={self.closedAt if self.closedAt else \"\"}\n|state={self.state}\n}}}}\"\"\"\n</code></pre>"},{"location":"#osprojects.osproject.Ticket.init_from_dict","title":"<code>init_from_dict(**records)</code>  <code>classmethod</code>","text":"<p>Inits Ticket from given args.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>@classmethod\ndef init_from_dict(cls, **records):\n    \"\"\"Inits Ticket from given args.\"\"\"\n    issue = Ticket()\n    for k, v in records.items():\n        setattr(issue, k, v)\n    return issue\n</code></pre>"},{"location":"#osprojects.osproject.Ticket.toWikiMarkup","title":"<code>toWikiMarkup()</code>","text":"<p>Returns Ticket in wiki markup.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>    def toWikiMarkup(self) -&gt; str:\n        \"\"\"Returns Ticket in wiki markup.\"\"\"\n        return f\"\"\"# {{{{Ticket\n|number={self.number}\n|title={self.title}\n|project={self.project}\n|createdAt={self.createdAt if self.createdAt else \"\"}\n|closedAt={self.closedAt if self.closedAt else \"\"}\n|state={self.state}\n}}}}\"\"\"\n</code></pre>"},{"location":"#osprojects.osproject.gitlog2wiki","title":"<code>gitlog2wiki(_argv=None)</code>","text":"<p>Cmdline interface to get gitlog entries in wiki markup.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def gitlog2wiki(_argv=None):\n    \"\"\"Cmdline interface to get gitlog entries in wiki markup.\"\"\"\n    parser = argparse.ArgumentParser(description=\"gitlog2wiki\")\n    if _argv:\n        _args = parser.parse_args(args=_argv)\n\n    osProject = OsProject.fromRepo()\n    commits = osProject.getCommits()\n    print(\"\\n\".join([c.toWikiMarkup() for c in commits]))\n</code></pre>"},{"location":"#osprojects.osproject.main","title":"<code>main(_argv=None)</code>","text":"<p>Main command line entry point.</p> Source code in <code>osprojects/osproject.py</code> <pre><code>def main(_argv=None):\n    \"\"\"Main command line entry point.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Issue2ticket\")\n    parser.add_argument(\"-o\", \"--owner\", help=\"project owner\")\n    parser.add_argument(\"-p\", \"--project\", help=\"name of the project\")\n    parser.add_argument(\n        \"--repo\",\n        action=\"store_true\",\n        help=\"get needed information form repository of current location\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--state\",\n        choices=[\"open\", \"closed\", \"all\"],\n        default=\"all\",\n        help=\"only issues with the given state\",\n    )\n    parser.add_argument(\"-V\", \"--version\", action=\"version\", version=\"gitlog2wiki 0.1\")\n\n    args = parser.parse_args(args=_argv)\n    if args.project and args.owner:\n        osProject = OsProject(\n            owner=args.owner,\n            project_id=args.project,\n        )\n    else:\n        osProject = OsProject.fromRepo()\n    tickets = osProject.getIssues(state=args.state)\n    print(\"\\n\".join([t.toWikiMarkup() for t in tickets]))\n</code></pre>"}]}